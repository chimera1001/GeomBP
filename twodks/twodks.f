
      SUBROUTINE MTTWO27(N,P,W,U,CW,CU,Z,X,LUB,
     1                   JDIM,MAXIT,NSMALL,MAXR,MAXL,LEVL,LEVK,
     1                   JCK,NNODE,ISCALE)
C************************************************************************
C THIS CODE IS IN A PRELIMINARY VERSION.
C
C COPYRIGHT SILVANO MARTELLO AND PAOLO TOTH, 2003.
C DEIS, UNIVERSITY OF BOLOGNA,
C VIALE RISORGIMENTO 2, 40136 BOLOGNA, ITALY.
C FAX =39 51 2093073
C E-MAIL  SMARTELLO@DEIS.UNIBO.IT
C         PTOTH@DEIS.UNIBO.IT

C
C FROM THE PAPER
C   S. MARTELLO, P. TOTH, "AN EXACT ALGORITHM FOR THE
C                          TWO-CONSTRAINT 0-1 KNAPSACK PROBLEM",
C                          OPERATIONS RESEARCH 51, 826-835, 2003
C
C THIS CODE CAN BE USED ONLY FOR RESEARCH OR TECHING PURPOSES,
C ONLY BY INDIVIDUALS WHO DIRECTLY RECEIVED IT FROM THE AUTHORS.
C************************************************************************
C
C THIS SUBROUTINE SOLVES THE TWO-CONSTRAINT 0-1 KNAPSACK PROBLEM
C
C MAXIMIZE  Z = P(1)*X(1) + ... + P(N)*X(N)
C
C SUBJECT TO:   W(1)*X(1) + ... + W(N)*X(N) .LE. CW ,
C               U(1)*X(1) + ... + U(N)*X(N) .LE. CU ,
C               X(J) = 0 OR 1  FOR J=1,...,N,
C
C N MUST BE <= 10000 WITH THE CURRENT DIMENSIONS.
C
C THE INPUT PROBLEM MUST SATISFY THE CONDITIONS
C
C   1) 2 .LE. N .LE. JDIM - 2 ;
C   2) P(J), CW, CU  POSITIVE INTEGERS,
C      W(J), U(J) NONNEGATIVE INTEGERS ;
C   3) MAX (W(J)) .LE. CW ;
C   4) MAX (U(J)) .LE. CU ;
C   5) W(1) + ... + W(N) .GT. CW .OR.
C      U(1) + ... + U(N) .GT. CU ;
C
C
C MEANING OF THE INPUT PARAMETERS:
C N   = NUMBER OF ITEMS   ( N <= 10000 WITH THE CURRENT DIMENSIONS);
C P(J) = PROFIT OF ITEM  J  (J=1,...,N);
C W(J) = WEIGHT OF ITEM  J  (J=1,...,N);
C U(J) = VOLUME OF ITEM  J  (J=1,...,N);
C CW   = WEIGHT CAPACITY OF THE KNAPSACK;
C CU   = VOLUME CAPACITY OF THE KNAPSACK;
C JDIM = DIMENSION OF THE FORMAL PARAMETER ARRAYS;
C MAXIT= MAX NUMBER OF BRANCH-DECISION NODES;
C MAXR = MAX NUMBER OF ITEMS FOR WHICH LOCALPAIR IS EXECUTED;
C JCK = 1 IF CHECK ON THE INPUT DATA IS DESIRED
C     = 0 OTHERWISE
C
C MEANING OF THE OUTPUT PARAMETERS:
C Z    = VALUE OF THE OPTIMAL SOLUTION IF  Z .GT. 0 ,
C      = ERROR IN THE INPUT DATA IF Z .LT. 0 :
C        CONDITION  - Z  IS VIOLATED;
C X(J) = 1 IF ITEM  J  IS IN THE OPTIMAL SOLUTION,
C      = 0 OTHERWISE.
C NNODE = NUMBER OF BRANCH-DECISION NODES (WITH COMPETE UPPER BOUND
C                                          EXECUTION)
C
C ARRAYS XX, MINW, POINTP, POINTW, PCOR, MAXP, RAT, IND ARE DUMMY.
C
C ALL THE PARAMETERS (BUT RAT) ARE INTEGER.
C
C INITIALIZATION
C THE BEST INCUMBENT SOLUTION IS ALWAYS IN Z AND X.
C REDUCTIONS ARE STORED IN XFIX (1, 0 IF FIXED, 2 IF FREE)
C AND IZ1 = TOTAL PROFIT OF ITEMS FIXED TO 1. REDUCTIONS ARE NOT
C NECESSARILY CONGRUENT WITH X.
C WHEN NEW HEURISTIC SOLUTIONS ARE SEARCHED FOR THE CURRENT REDUCED
C PROBLEM (AND IN BRANCH-AND-BOUND) THE TARGET IS THUS ZZ = Z - IZ1
C THE CURENT BEST SOLUTION FOR THE REDUCED PROBLEM IS IN ZLOC AND XX
C (CONGRUENT WITH REDUCTIONS): WHEN NEW REDUCTIONS OCCUR, IF THEY ARE
C NOT CONGRUENT WITH ZLOC, ZLOC IS CANCELLED AND A NEW SOLUTION IS
C DETERMINED BY TWOKPUB
      IMPLICIT NONE
      INTEGER N,Z,JCK,CW,CU,MAXIT,MAXR,LUB,JDIM,NNODE
      INTEGER P(JDIM),W(JDIM),U(JDIM),X(JDIM)
      INTEGER PP(10002),WW(10002),UU(10002),XX(10002)
      INTEGER PRED(10002),WRED(10002),URED(10002),XRED(10002)
      INTEGER IND(10002),PCOR(10002),WCOR(10002),UCOR(10002)
      INTEGER WURED(10002),CWU
      INTEGER XLAGR(10002),XC(10002),XLL(10002),XLLC(10002)
      INTEGER COMPACTIN(10002),COMPACTOUT(10002),JSTART
      INTEGER SCALP(10002),XFIX(10002)
      DOUBLE PRECISION RAT(10002), RINF
      INTEGER NN,I,J,JJ,NP1,IZ1,NNF,FLSORTPW,ZOLD
      INTEGER ICW,ICU,ZZ,CONS1OPT,COMPUTE,ISCALE,LAMBDAU,LAMUC,LAMWC
C
      INTEGER NITER,NITER1
      INTEGER ZFLAG,ZLOC,ZLOCNEW,ZLOCOLD
      INTEGER FLGLOC
      INTEGER UBFIRST,UBLAST,LOWER
      INTEGER NSMALL,FLAGLOC
      INTEGER SUMW, SUMU, MAXW, MAXU, FLAGPREP, LEVPREP
      INTEGER MAXL, LEVL, LEVK
      INTEGER NCOMP0
      INTEGER DUMMY(10002)
      REAL TFIRST,TLAST
      REAL TIMELIMIT, T1, T2
      COMMON /XXTIME/ TIMELIMIT, T1
      COMMON /UB/ UBFIRST,TFIRST,UBLAST,TLAST,LOWER
      COMMON /COMP/ NCOMP0
      COMMON NNF,NITER1
C IF LOWER .GT 0 ON OUTPUT THEN LOWER = LOWER BOUND AT THE ROOT NODE
C OTHERWISE LOWER BOUND = UPPER BOUND AT THE ROOT NODE
      NCOMP0 = 0
      FLAGLOC = 0
      IF ( N .GE. NSMALL ) FLAGLOC = 1
      LOWER = -1
C
C LOCAL VARIABLES:
C IZ1          = TOTAL PROFIT OF THE ITEMS FIXED TO 1
C
C INITIALIZATION
C
      NNODE = 0
C      ISCALE = 1000
      Z = 0
      IF (JCK .EQ. 1 ) CALL CHMTTWO(N,P,W,U,CW,CU,Z,JDIM)
      IF ( Z .LT. 0 ) RETURN
      FLSORTPW = 0
      CONS1OPT = 1
      LAMBDAU = 0
      LUB = 0
      DO 5 J=1,N
        COMPACTIN(J) = J
        PCOR(J) = P(J)*ISCALE
        SCALP(J) = PCOR(J)
C SCALP = SCALED INPUT PROFITS, FOR USE IN THE INITIALIZATION PHASE
        WCOR(J) = W(J)
        UCOR(J) = U(J)
        XFIX(J) = 2
    5 CONTINUE
      ICW = CW
      ICU = CU
      IZ1 = 0
      NNF = N
      Z = -1
      LAMUC = 0
      ZLOC = 0
      CALL SECOND(T1)
C
C ITERATE UPPER BOUND COMPUTATION AND REDUCTION
C
   10 ZZ = Z - IZ1
      FLAGPREP = 1
      COMPUTE = 1
      ZFLAG = 0
      ZOLD = Z
      JSTART = - 1
      CALL TWOKPUB12(NNF,PCOR,WCOR,UCOR,ICW,ICU,1,1,FLAGPREP,ZZ,X,N,
     1     XFIX,ISCALE,JDIM,FLSORTPW,CONS1OPT,COMPACTIN,SCALP,W,U,
     2              LUB,LAMBDAU,XLAGR,XLL,LAMUC,LAMWC,XC,XLLC,
     3              COMPUTE,NITER,NN,PP,WW,UU,ZLOCNEW,WURED,COMPACTOUT,
     4              JSTART,N,1,0)
C      WRITE (6,8364) NITER
 8364 FORMAT('    ############### NITER =',I6)
C ON OUTPUT, WURED IS THE BEST SOLUTION FOUND FOR THE CURRENT
C (COMPACT) PROBLEM AND ITS VALUE IS ZLOCNEW/ISCALE
      CALL SECOND(T2)
      IF ( ZOLD .EQ. -1) THEN
        UBFIRST = LUB
        TFIRST = T2 - T1
      ELSE
        UBLAST = LUB + IZ1
        TLAST = T2 - T1
      ENDIF
      ZLOCNEW = ZLOCNEW/ISCALE
      IF ( ZZ + IZ1 .GT. Z ) Z = ZZ + IZ1
C IF SOME ELEMENT HAS BEEN ELIMINATED BY TWOKPUB, ZLOC IS CANCELED
      IF ( NN .LT. NNF ) ZLOC = 0
      RINF = N*FLOAT(Z)
C FOR STATISTICS
      IF ( NNF .EQ. N ) NITER1 = NITER
C FOR STATISTICS
      IF ( Z .LT. ZOLD ) WRITE (6,666) ZZ+IZ1, ZOLD
      IF ( Z .LT. ZOLD ) WRITE (7,666) ZZ+IZ1, ZOLD
  666 FORMAT ('   ************************ LOWER BOUND CALA',2I10)
      IF ( ZLOCNEW .GT. ZLOC ) THEN
        ZLOC = ZLOCNEW
        DO 12 J=1,NN
          XX(J) = WURED(J)
   12   CONTINUE
  122   ZLOCOLD = ZLOC
        CALL LOCAL4(NN,PP,WW,UU,ICW,ICU,
     1              ZLOC,XX,COMPACTOUT,-1,X,JDIM,ISCALE)
        IF ( LUB .EQ. ZLOC ) GO TO 125
        IF ( ZLOC .GT. ZLOCOLD ) GO TO 122
  125   IF ( ZLOC .GT. ZZ ) THEN
          ZZ = ZLOC
          DO 13 J=1,N
            X(J) = XFIX(J)
   13     CONTINUE
          DO 14 JJ=1,NN
            J = COMPACTOUT(JJ)
            X(J) = XX(JJ)
   14     CONTINUE
          Z = ZZ + IZ1
          IF ( LUB .EQ. ZZ ) THEN
            NNF = 0
            LUB = Z
            RETURN
          ENDIF
        ENDIF
      ENDIF
      IF ( LUB .GT. ZZ ) GO TO 15
      NNF = 0
      LUB = Z
      RETURN
C THE CURRENT INSTANCE IS (NN,PP/ISCALE,WW,UU,ICW,ICU),
C WITH COMPACTOUT POINTING TO THE INPUT INSTANCE.
C THE UPPER BOUND IS LUB AND THE CORRESPONDING VECTOR IS XLL.
C THE LOWER BOUND SOLUTION HAS VALUE ZZ AND IS STORED IN XX.
C THE ITEMS ARE SORTED BY DECREASING RATIOS PP(J)/WW(J), BREAKING TIES
C BY DECREASING VALUES OF WW(J).
C
C REDUCTION
C
C DEFINE THE SURROGATE VECTOR USING THE OPTIMAL MULTIPLIERS
   15   IF ( LAMUC .EQ. 0 .AND. LAMWC .EQ. 0 ) LAMWC = 1
        DO 18 J=1,NN
        WURED(J) = LAMWC*WW(J) + LAMUC*UU(J)
        IF ( WURED(J) .NE. 0 ) THEN
          RAT(J) = DBLE(PP(J))/WURED(J)
        ELSE
          RAT(J) = RINF
        ENDIF
        IND(J) = J
   18 CONTINUE
      CALL SORTRMDD(NN,RAT,IND,JDIM,WURED)
      DO 20 J=1,NN
        JJ = IND(J)
        PRED(J) = PP(JJ)/ISCALE
        WRED(J) = WW(JJ)
        URED(J) = UU(JJ)
        XRED(J) = XX(JJ)
        WURED(J) = LAMWC*WW(JJ) + LAMUC*UU(JJ)
        IF ( WURED(J) .NE. 0 ) THEN
          RAT(J) = DBLE(PRED(J))/WURED(J)
        ELSE
          RAT(J) = RINF
        ENDIF
   20 CONTINUE
      CWU = LAMWC*ICW + LAMUC*ICU
      NP1 = NN + 1
   22 ZLOCOLD = ZLOC
      CALL LOCAL4(NN,PRED,WRED,URED,ICW,ICU,
     1             ZLOC,XRED,XRED,-1,XRED,JDIM,1)
      IF ( LUB .EQ. ZLOC ) GO TO 25
      IF ( ZLOC .GT. ZLOCOLD ) GO TO 22
   25 IF ( ZLOC .GT. ZZ ) THEN
        ZZ = ZLOC
        DO 26 J=1,N
          X(J) = XFIX(J)
   26   CONTINUE
        DO 27 JJ=1,NN
          J = COMPACTOUT(IND(JJ))
          X(J) = XRED(JJ)
   27   CONTINUE
        Z = ZZ + IZ1
        IF ( LUB .EQ. ZZ ) THEN
          NNF = 0
          LUB = Z
          RETURN
        ENDIF
      ENDIF
      DO 28 JJ=1,NN
        XX(IND(JJ)) = XRED(JJ)
   28 CONTINUE
      IF ( LUB .GT. ZZ ) GO TO 30
      NNF = 0
      LUB = Z
      RETURN
C INRED2 RECEIVES COMPACTOUT PRODUCED BY THE UPPER BOUND COMPUTATION
C AS INPUT COMPACT VECTOR AND STORES IN COMPACTIN ITS OUTPUT COMPACT
C VECTOR. HENCE THE RESULTING COMPACTIN IS READY FOR THE NEXT ITERATION
C INRED2 DEFINES BOTH THE COMPACT (REDUCED) VERSIONS OF PRED,WRED,URED
C (SORTED BY PROFIT PER UNIT SURROGATE VALUE) AND OF PCOR,WCOR,UCOR
C (SORTED BY PROFIT PER UNIT WEIGHT )
   30 CALL INRED2(NN,PRED,ISCALE,WRED,URED,ICW,ICU,WURED,CWU,RAT,
     1            COMPACTOUT,IND,ZZ,NNF,XFIX,IZ1,NP1,COMPACTIN,
     2            PCOR,WCOR,UCOR)
      FLSORTPW = 1
      WRITE (6,3388) NN, NNF
 3388 FORMAT ('   NN, NNF =',2I5)
      IF ( NNF .GT. 0 ) GO TO 75
C THE INSTANCE HAS BEEN COMPLETELY REDUCED
      LUB = Z
      IF ( IZ1 .LE. Z ) RETURN
      Z = IZ1
      DO 70 J=1,N
        X(J) = XFIX(J)
   70 CONTINUE
      LUB = Z
      RETURN
C CHECK WHETHER THE INITIAL BOUND-AND-REDUCTION CAN BE ITERATED
   75 IF ( NNF .EQ. NN ) GO TO 81
C ZLOC AND XX MUST BE UPDATED (IF REDUCTION CONGRUENT WITH XX) OR CANCELED
      I = 0
      DO 77 J=1,NN
        JJ = COMPACTOUT(J)
        IF ( XFIX(JJ) .EQ. 2 ) THEN
          I = I + 1
          XX(I) = XX(J)
          GO TO 77
        ENDIF
        IF ( XFIX(JJ) .NE. XX(J) ) GO TO 78
        IF ( XFIX(JJ) .EQ. 1 ) ZLOC = ZLOC - P(JJ)
   77 CONTINUE
      GO TO 10
   78 ZLOC = 0
      GO TO 10
   81 IF ( ZFLAG .EQ. -1 ) GO TO 188
      ZFLAG = -1
      IF ( NN .GT. MAXR ) GO TO 188
   82 ZLOCOLD = ZLOC
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCALPAIR4(NN,PRED,WRED,URED,ICW,ICU,
     1             ZLOC,XRED,XRED,-1,XRED,JDIM,1)
      ENDIF
      IF ( LUB .EQ. ZLOC ) GO TO 83
C REMOVE THE NEXT COMMENT TO ITERATE
C      IF ( ZLOC .GT. ZLOCOLD ) GO TO 82
   83 IF ( ZLOC .LE. ZZ ) GO TO 88
      ZZ = ZLOC
      DO 84 J=1,N
        X(J) = XFIX(J)
        COMPACTOUT(J) = COMPACTIN(J)
   84 CONTINUE
      DO 85 JJ=1,NN
        J = COMPACTOUT(IND(JJ))
        X(J) = XRED(JJ)
   85 CONTINUE
      Z = ZZ + IZ1
      IF ( LUB .EQ. ZZ ) THEN
        NNF = 0
        LUB = Z
        RETURN
      ENDIF
   88 DO 89 JJ=1,NN
        XX(IND(JJ)) = XRED(JJ)
   89 CONTINUE
  182 ZLOCOLD = ZLOC
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCALPAIR4(NN,PP,WW,UU,ICW,ICU,
     1             ZLOC,XX,XX,ZFLAG,XX,JDIM,ISCALE)
      ENDIF
      IF ( LUB .EQ. ZLOC ) GO TO 183
C REMOVE THE NEXT COMMENT TO ITERATE
C      IF ( ZLOC .GT. ZLOCOLD ) GO TO 182
  183 IF ( ZLOC .LE. ZZ ) GO TO 188
      ZZ = ZLOC
      DO 184 J=1,N
        X(J) = XFIX(J)
        COMPACTOUT(J) = COMPACTIN(J)
  184 CONTINUE
      DO 185 JJ=1,NN
        J = COMPACTOUT(JJ)
        X(J) = XX(JJ)
  185 CONTINUE
      Z = ZZ + IZ1
      IF ( LUB .EQ. ZZ ) THEN
        NNF = 0
        LUB = Z
        RETURN
      ENDIF
      GO TO 30
C LAST ATTEMPT TO IMPROVE THE INCUMBENT SOLUTION BEFORE BRANCH-AND-BOUND:
C COMPUTE UPPER BOUND LUB AND XLAGR OF THE ROOT NODE
  188 FLGLOC = 1
      IF ( NN .GT. MAXR ) FLGLOC = 0
      ZLOCOLD = ZZ
      ZLOC = ZZ
      DO 290 J=1,NN
        PRED(J) = PRED(J)*ISCALE
  290 CONTINUE
      CALL KPUB11(NN,PRED,WRED,URED,ICW,ICU,ZLOC,XRED,ISCALE,
     1           JDIM,LUB,LAMBDAU,XLAGR,FLGLOC,FLAGLOC)
C      WRITE (9,6666) NN
C      WRITE (9,6666) (PRED(J)/ISCALE,J=1,N)
C      WRITE (9,6666) (WRED(J),J=1,N)
C      WRITE (9,6666) (URED(J),J=1,N)
C      WRITE (9,6666) ICW,ICU
C      WRITE (9,6666) ZLOC
C      WRITE (9,6666) (XLAGR(J),J=1,N)
C      WRITE (6,6666) NN
C      WRITE (6,6666) (PRED(J)/ISCALE,J=1,N)
C      WRITE (6,6666) (WRED(J),J=1,N)
C      WRITE (6,6666) (URED(J),J=1,N)
C      WRITE (6,6666) ICW,ICU
C      WRITE (6,6666) ZLOC
C      WRITE (6,6666) (XLAGR(J),J=1,N)
 6666 FORMAT(1X,10I7)
C      WRITE (9,6666) LUB
C      WRITE (6,6666) LUB
      IF ( ZLOC .LE. ZZ ) GO TO 288
      ZZ = ZLOC
      DO 284 J=1,N
        X(J) = XFIX(J)
        COMPACTOUT(J) = COMPACTIN(J)
  284 CONTINUE
      DO 285 JJ=1,NN
        J = COMPACTOUT(IND(JJ))
        X(J) = XRED(JJ)
  285 CONTINUE
      Z = ZZ + IZ1
      IF ( LUB .EQ. ZZ ) THEN
        NNF = 0
        LUB = Z
        RETURN
      ENDIF
      DO 286 JJ=1,NN
        XX(IND(JJ)) = XRED(JJ)
        PRED(JJ) = PRED(JJ)/ISCALE
  286 CONTINUE
      GO TO 30
  288 IF ( LUB + IZ1 .GT. Z ) GO TO 295
      NNF = 0
      LUB = Z
      RETURN
C
C INITIALIZE FOR BRANCH-AND-BOUND
C
  295 DO 90 J=1,NN
        JJ = IND(J)
        COMPACTOUT(J) = COMPACTIN(JJ)
        XC(J) = XLLC(JJ)
   90 CONTINUE
      LOWER = ZZ + IZ1
C THE CURRENT INSTANCE IS (NN,PRED/ISCALE,WRED,URED,ICW,ICU),
C WITH COMPACTOUT POINTING TO THE ORIGINAL INPUT INSTANCE.
C
C THE UPPER BOUND IS LUB, THE CORRESPONDING VECTOR IS XLAGR,
C AND THE CORRESPONDING MULTIPLIER IS LAMBDAU, WHILE
C THE OPTIMAL MULTIPLIERS FOR THE CONTINUOUS RELAXATION ARE
C LAMUC (FOR THE UU CONSTRAINT), LAMWC (FOR THE WW CONSTRAINT)
C AND THE CORRESPONDING VECTOR IS XC.
C
C THE LOWER BOUND SOLUTION HAS VALUE ZZ AND IS STORED IN X,
C IN THE LOCATIONS CORRESPONDING TO THE NON REDUCED ITEMS
C
C THE ITEMS ARE SORTED BY DECREASING RATIOS PRED(J)/WURED(J),
C BREAKING TIES BY DECREASING VALUES OF WURED(J).
C
      CALL SECOND(T2)
      UBLAST = LUB + IZ1
      TLAST = T2 - T1
      WRITE (6, 100) ZZ+IZ1
  100 FORMAT(' HEURISTIC SOLUTION =',I10)
      CALL BANDB22(NN,PRED,ISCALE,WRED,URED,ICW,ICU,LUB,XLAGR,LAMBDAU,
     1           XC,LAMUC,LAMWC,WURED,ZZ,XX,JDIM,MAXIT,NNODE,FLAGLOC,
     2           XLL,XLLC,IND,PCOR,WCOR,UCOR,DUMMY,
     3           COMPACTIN,SCALP,RAT,PP,WW,UU,MAXL,LEVL,LEVK)
  103 LUB = LUB + IZ1
      IF ( ZZ + IZ1 .LE. Z ) RETURN
C DEFINE A NEW SOLUTION FOR THE INPUT INSTANCE
      DO 105 J=1,N
        X(J) = XFIX(J)
  105 CONTINUE
      DO 110 JJ=1,NN
        J = COMPACTOUT(JJ)
        X(J) = XX(JJ)
  110 CONTINUE
      Z = ZZ + IZ1
      RETURN
      END
      SUBROUTINE LOCAL4(NN,PP,WW,UU,ICW,ICU,ZZ,XX,IND,Z,X,JDIM,ISCALE)
C IMPROVE THE CURRENT SOLUTION XX OF VALUE ZZ FOR
C INSTANCE (NN,PP/ISCALE,WW,UU,ICW,ICU) BY REMOVING FROM THE SOLUTION
C    - ALL ITEMS FOLLOWING THE CRITICAL ONE, AND
C    - IN TURN, EACH OF THE LAST 100 ITEMS PRECEDING THE CRITICAL ONE
C      IN REVERSE ORDER,
C AND EXECUTING THE GREEDY ALGORITHM.
C FIRST DETERMINE THE BEST EXCHANGE, THEN PERFORM IT.
C IF Z .GE. 0 THEN
C   ALSO STORE THE SOLUTION IN THE LOCATIONS OF X POINTED BY IND AND
C   UPDATE Z (SAME INCREASE AS ZZ)
      IMPLICIT NONE
      INTEGER ISCALE,JDIM
      INTEGER PP(JDIM),WW(JDIM),UU(JDIM),XX(JDIM),IND(JDIM),X(JDIM)
      INTEGER NN,ICW,ICU,ZZ,Z
      INTEGER I,J,ZZINPUT,CWR,CUR,CW,CU,MINW,MINU
      INTEGER XONE(10002),NEWONES,NEWP,JJ,II
      INTEGER BESTXONE(10002),BESTONES,BESTIMP,BESTI
      INTEGER FIRSTZERO,ICOUNT,SUMONE
C COMPUTE THE RESIDUAL CAPACITIES AND THE MINIMAL WEIGHTS
      ZZINPUT = ZZ
      CWR = ICW
      CUR = ICU
      MINW = ICW + 1
      MINU = ICU + 1
      FIRSTZERO = 0
      SUMONE = 0
      DO 10 J=1,NN
        IF ( FIRSTZERO .EQ. 0 ) THEN
          IF ( XX(J) .EQ. 0 ) THEN
            FIRSTZERO = J
            IF ( WW(J) .LT. MINW ) MINW = WW(J)
            IF ( UU(J) .LT. MINU ) MINU = UU(J)
          ELSE
            CWR = CWR - WW(J)
            CUR = CUR - UU(J)
            SUMONE = SUMONE + PP(J)
          ENDIF
        ELSE
          IF ( WW(J) .LT. MINW ) MINW = WW(J)
          IF ( UU(J) .LT. MINU ) MINU = UU(J)
        ENDIF
   10 CONTINUE
      ICOUNT = 0
      BESTIMP = 0
      DO 100 II=1,FIRSTZERO-1
        I = FIRSTZERO - II
        ICOUNT = ICOUNT + 1
        IF ( ICOUNT .GT. 100 ) GO TO 110
C REMOVE ITEM I AND APPLY THE GREEDY ALGORITHM, STORING IN XONE
C THE INDICES OF THE ITEMS ADDED TO THE CURRENT SOLUTION XX
        CW = CWR + WW(I)
        CU = CUR + UU(I)
        IF ( MINW .GT. CW ) GO TO 100
        IF ( MINU .GT. CU ) GO TO 100
        NEWONES = 0
        NEWP = 0
        DO 50 J=FIRSTZERO,NN
          IF ( WW(J) .GT. CW ) GO TO 50
          IF ( UU(J) .GT. CU ) GO TO 50
          NEWONES = NEWONES + 1
          XONE(NEWONES) = J
          NEWP = NEWP + PP(J)
          CW = CW - WW(J)
          CU = CU - UU(J)
          IF ( MINW .GT. CW ) GO TO 60
          IF ( MINU .GT. CU ) GO TO 60
   50   CONTINUE
   60   IF ( (SUMONE - PP(I) + NEWP) - ZZ*ISCALE .LE. BESTIMP )
     1                                                GO TO 100
C STORE THE NEW INCUMBENT IMPROVEMENT
        BESTI = I
        BESTIMP = (SUMONE - PP(I) + NEWP) - ZZ*ISCALE
        BESTONES = NEWONES
        DO 70 J=1,BESTONES
          BESTXONE(J) = XONE(J)
   70   CONTINUE
  100 CONTINUE
  110 IF ( BESTIMP .EQ. 0 ) GO TO 200
C STORE THE NEW SOLUTION
      I = BESTI
      NEWONES = BESTONES
      WRITE (6,65) ZZ, I, BESTIMP
   65 FORMAT (' SOLUTION IMPROVED BY LOCAL4    ',4I10)
      ZZ = ZZ + BESTIMP/ISCALE
      DO 160 J=FIRSTZERO+1,NN
        XX(J) = 0
  160 CONTINUE
      XX(I) = 0
      DO 170 J=1,NEWONES
        JJ = BESTXONE(J)
        XX(JJ) = 1
  170 CONTINUE
  200 IF ( ZZ .EQ. ZZINPUT ) RETURN
      IF ( Z .LT. 0 ) RETURN
      Z = Z - ZZINPUT + ZZ
      DO 220 J=1,NN
        X(IND(J)) = XX(J)
  220 CONTINUE
      RETURN
      END
      SUBROUTINE LOCALPAIR4(NN,PP,WW,UU,ICW,ICU,ZZ,XX,IND,Z,X,
     1                     JDIM,ISCALE)
C IMPROVE THE CURRENT SOLUTION XX OF VALUE ZZ FOR
C INSTANCE (NN,PP/ISCALE,WW,UU,ICW,ICU) BY REMOVING FROM THE SOLUTION
C    - ALL ITEMS FOLLOWING THE CRITICAL ONE, AND
C    - IN TURN, EACH PAIR OF THE LAST 10 ITEMS PRECEDING THE CRITICAL ONE
C      IN REVERSE ORDER,
C AND EXECUTING THE GREEDY ALGORITHM.
C FIRST DETERMINE THE BEST EXCHANGE, THEN PERFORM IT.
C IF Z .GE. 0 THEN
C   ALSO STORE THE SOLUTION IN THE LOCATIONS OF X POINTED BY IND AND
C   UPDATE Z (SAME INCREASE AS ZZ)
      IMPLICIT NONE
      INTEGER ISCALE,JDIM
      INTEGER PP(JDIM),WW(JDIM),UU(JDIM),XX(JDIM),IND(JDIM),X(JDIM)
      INTEGER NN,ICW,ICU,ZZ,Z
      INTEGER I,J,ZZINPUT,CWR,CUR,CW,CU,MINW,MINU
      INTEGER XONE(10002),NEWONES,NEWP,JJ,II,K,KK
      INTEGER BESTXONE(10002),BESTONES,BESTIMP,BESTI,BESTK
      INTEGER FIRSTZERO,ICOUNT,KCOUNT,SUMONE
C COMPUTE THE RESIDUAL CAPACITIES AND THE MINIMAL WEIGHTS
      ZZINPUT = ZZ
      CWR = ICW
      CUR = ICU
      MINW = ICW + 1
      MINU = ICU + 1
      FIRSTZERO = 0
      SUMONE = 0
      DO 10 J=1,NN
        IF ( FIRSTZERO .EQ. 0 ) THEN
          IF ( XX(J) .EQ. 0 ) THEN
            FIRSTZERO = J
            IF ( WW(J) .LT. MINW ) MINW = WW(J)
            IF ( UU(J) .LT. MINU ) MINU = UU(J)
          ELSE
            CWR = CWR - WW(J)
            CUR = CUR - UU(J)
            SUMONE = SUMONE + PP(J)
          ENDIF
        ELSE
          IF ( WW(J) .LT. MINW ) MINW = WW(J)
          IF ( UU(J) .LT. MINU ) MINU = UU(J)
        ENDIF
   10 CONTINUE
C      WRITE (9,123) ZZ
C      WRITE (9,123) (PP(J)/1000, J=1,NN)
C      WRITE (9,123) (WW(J), J=1,NN)
C      WRITE (9,123) (UU(J), J=1,NN)
C      WRITE (9,123) ICW, ICU
C      WRITE (9,123) (XX(J), J=1,NN)
C      WRITE (9,123) CWR, CUR
C      WRITE (6,123) ZZ
C      WRITE (6,123) (PP(J)/1000, J=1,NN)
C      WRITE (6,123) (WW(J), J=1,NN)
C      WRITE (6,123) (UU(J), J=1,NN)
C      WRITE (6,123) ICW, ICU
C      WRITE (6,123) (XX(J), J=1,NN)
C      WRITE (6,123) CWR, CUR
  123 FORMAT(10I8)
      ICOUNT = 0
      BESTIMP = 0
      DO 100 II=1,FIRSTZERO-2
        I = FIRSTZERO - II
        ICOUNT = ICOUNT + 1
        IF ( ICOUNT .GT. 10 ) GO TO 110
C CONSIDER ALL PAIRS OF ITEMS IN THE SOLUTION INCLUDING ITEM I
        KCOUNT = 0
        DO 90 KK=1,I-1
          K = I - KK
          KCOUNT = KCOUNT + 1
          IF ( KCOUNT .GT. 10 ) GO TO 100
C REMOVE ITEMS I AND K, AND APPLY THE GREEDY ALGORITHM, STORING IN XONE
C THE INDICES OF THE ITEMS ADDED TO THE CURRENT SOLUTION XX
          CW = CWR + WW(I) + WW(K)
          CU = CUR + UU(I) + UU(K)
          IF ( MINW .GT. CW ) GO TO 90
          IF ( MINU .GT. CU ) GO TO 90
          NEWONES = 0
          NEWP = 0
          DO 50 J=FIRSTZERO,NN
            IF ( WW(J) .GT. CW ) GO TO 50
            IF ( UU(J) .GT. CU ) GO TO 50
            NEWONES = NEWONES + 1
            XONE(NEWONES) = J
            NEWP = NEWP + PP(J)
            CW = CW - WW(J)
            CU = CU - UU(J)
            IF ( MINW .GT. CW ) GO TO 60
            IF ( MINU .GT. CU ) GO TO 60
   50     CONTINUE
   60     IF ( (SUMONE - PP(I) - PP(K) + NEWP) - ZZ*ISCALE
     1                                        .LE. BESTIMP ) GO TO 90
C STORE THE NEW INCUMBENT IMPROVEMENT
          BESTI = I
          BESTK = K
          BESTIMP = (SUMONE - PP(I) - PP(K) + NEWP) - ZZ*ISCALE
          BESTONES = NEWONES
          DO 70 J=1,BESTONES
            BESTXONE(J) = XONE(J)
   70     CONTINUE
   90   CONTINUE
  100 CONTINUE
  110 IF ( BESTIMP .EQ. 0 ) GO TO 200
C STORE THE NEW SOLUTION
      I = BESTI
      K = BESTK
      NEWONES = BESTONES
      WRITE (6,65) ZZ, I, K, BESTIMP
   65 FORMAT (' SOLUTION IMPROVED BY LOCALPAIR4    ',4I10)
      ZZ = ZZ + BESTIMP/ISCALE
      DO 160 J=FIRSTZERO+1,NN
        XX(J) = 0
  160 CONTINUE
      XX(I) = 0
      XX(K) = 0
      DO 170 J=1,NEWONES
        JJ = BESTXONE(J)
        XX(JJ) = 1
  170 CONTINUE
C      WRITE (9,123) ZZ
C      WRITE (9,123) (PP(J)/1000, J=1,NN)
C      WRITE (9,123) (WW(J), J=1,NN)
C      WRITE (9,123) (UU(J), J=1,NN)
C      WRITE (9,123) ICW, ICU
C      WRITE (9,123) (XX(J), J=1,NN)
C      WRITE (6,123) ZZ
C      WRITE (6,123) (PP(J)/1000, J=1,NN)
C      WRITE (6,123) (WW(J), J=1,NN)
C      WRITE (6,123) (UU(J), J=1,NN)
C      WRITE (6,123) ICW, ICU
C      WRITE (6,123) (XX(J), J=1,NN)
  200 IF ( ZZ .EQ. ZZINPUT ) RETURN
      IF ( Z .LT. 0 ) RETURN
      Z = Z - ZZINPUT + ZZ
      DO 210 J=1,NN
        X(IND(J)) = XX(J)
  210 CONTINUE
      RETURN
      END
      SUBROUTINE CHMTTWO(N,P,W,U,CW,CU,Z,JDIM)
C
C CHECK THE INPUT DATA.
C
      IMPLICIT NONE
      INTEGER JDIM, N, JSW, JSU, J
      INTEGER P(JDIM),W(JDIM),U(JDIM),CW,CU,Z
      IF ( N .GE. 2 .AND. N .LE. JDIM - 1 ) GO TO 10
      Z = - 1
      RETURN
   10 IF ( CW .GT. 0 .AND. CU .GT. 0) GO TO 30
   20 Z = - 2
      RETURN
   30 DO 40 J=1,N
        IF ( P(J) .LE. 0 ) GO TO 20
        IF ( W(J) .LT. 0 ) GO TO 20
        IF ( U(J) .LT. 0 ) GO TO 20
   40 CONTINUE
      RETURN
      END
      SUBROUTINE SIMPLEUB1(NCOR,PCOR,WUCOR,
     1                     CHS,IP,LL,LLP1,
     2                     WCOR,UCOR,CW,CU,JDIM,LUB)
C
C COMPUTE THE MARTELLO-TOTH UPPER BOUND FOR THE SURROGATE RELAXATION
C OF THE TWO-DIMENSIONAL KP
C
C    MAX PCOR(1)*X(1) + ... + PCOR(NCOR)*X(NCOR)
C        WCOR(1)*X(1) + ... + WCOR(NCOR)*X(NCOR) .LE. CW
C        UCOR(1)*X(1) + ... + UCOR(NCOR)*X(NCOR) .LE. CU
C                X(1),  ...              X(NCOR) = 0 OR 1
C
C I.E., FOR THE ONE-DIMENSIONAL KP
C
C    MAX PCOR(1)*X(1)  + ... +  PCOR(NCOR)*X(NCOR)
C        WUCOR(1)*X(1) + ... + WUCOR(NCOR)*X(NCOR) .LE. CWU
C                X(1),   ...               X(NCOR) = 0 OR 1
C
C INPUT:
C   CURRENT SURROGATE PROBLEM: NCOR, PCOR, WUCOR WITH:
C         CHS  = RESIDUAL CAPACITY AFTER ALL FEASIBLE ITEMS FROM 1 TO LL
C                HAVE BEEN INSERTED;
C         IP   = PROFIT OF ALL FEASIBLE ITEMS FROM 1 TO LL;
C         LL   = LAST FEASIBLE ITEM INSERTED;
C         LLP1 = NEXT FEASIBLE ITEM
C   CURRENT PROBLEM: NCOR, PCOR, WCOR, UCOR, CW, CU
C
C OUTPUT:
C   UPPER BOUND LUB
C   LLP1 = CRITICAL ITEM FOR THE INPUT INSTANCE
C   LL   = LAST FEASIBLE ITEM CURRENTLY INSERTED;
C   CHS  = RESIDUAL CAPACITY AFTER ALL FEASIBLE ITEMS FROM 1 TO LL
C                HAVE BEEN INSERTED;
C   IP   = PROFIT OF ALL FEASIBLE ITEMS FROM 1 TO LL
C
      IMPLICIT NONE
      INTEGER JDIM, NCOR, PCOR(JDIM), WUCOR(JDIM),
     1        WCOR(JDIM), UCOR(JDIM), CW, CU, LUB
      INTEGER CHS, IP, L, LL, LTRUE, LLP1, LLP2, LIM1
      REAL    A, B
      LTRUE = LL
      DO 10 L=LLP1,NCOR
        IF ( WCOR(L) .GT. CW ) GO TO 10
        IF ( UCOR(L) .GT. CU ) GO TO 10
        IF ( WUCOR(L) .GT. CHS ) GO TO 20
        IP = IP + PCOR(L)
        CHS = CHS - WUCOR(L)
        LTRUE = L
   10 CONTINUE
      LL = LTRUE
      LLP1 = NCOR + 1
      LUB = IP
      RETURN
   20 LLP1 = L
      LL = LTRUE
      DO 30 LLP2=LLP1+1,NCOR
        IF ( WCOR(LLP2) .LE. CW .AND. UCOR(LLP2) .LE. CU ) GO TO 40
   30 CONTINUE
      LLP2 = NCOR + 1
   40 LUB = IP + CHS*DBLE(PCOR(LLP2))/WUCOR(LLP2)
      A = WUCOR(LLP1) - CHS
      B = IP + PCOR(LLP1)
      LIM1 = B - A*DBLE(PCOR(LL))/WUCOR(LL)
      IF ( LIM1 .GT. LUB ) LUB = LIM1
      RETURN
      END
      SUBROUTINE TWOKPUB12(NCOR,PCOR,WCOR,UCOR,CH,DH,MINW,MINU,
     1              FLAGPREP,ZCOR,X,N,XFIX,ISCALE,JDIM,FLSORTPW,
     2              CONS1OPT,COMPACTIN,PORIG,WORIG,UORIG,
     3              LUB,LAMBDAU,XLAGR,XLL,LAMUC,LAMWC,XC,XLLC,
     4              COMPUTE,NITER,NN,PP,WW,UU,ZBIG,XX,COMPACTOUT,JSTART,
     5              MAXL,LEVL,II)
C
C COMPUTE THE LAGRANGIAN UPPER BOUND FOR THE TWO-DIMENSIONAL KP
C
C    MAX PCOR(1)*X(1) + ... + PCOR(NCOR)*X(NCOR)
C        WCOR(1)*X(1) + ... + WCOR(NCOR)*X(NCOR) .LE. CH
C        UCOR(1)*X(1) + ... + UCOR(NCOR)*X(NCOR) .LE. DH
C                X(1),  ...              X(NCOR) = 0 OR 1
C
C THEN IMPROVE IT BY EXACTLY SOLVING A 0-1 KNAPSACK PROBLEM
C FOR THE OPTIMAL MULTIPLIERS
C
C INPUT:
C   CURRENT PROBLEM: NCOR, PCOR, WCOR, UCOR ,
C                    CH, DH WITH BEST INCUMBENT SOLUTION VALUE ZCOR;
C   COMPACTIN(J) = POINTER TO THE ORIGINAL INSTANCE PORIG, WORIG, UORIG
C                   (J=1,...,NCOR)
C   XFIX(J) = 1 (FIXED TO 1), 0 (FIXED TO 0) OR 2 (NOT FIXED) AFTER THE
C               LAST EXECUTION OF INRED (J=1, ..., N ORIGINAL). WHEN THE
C               INCUMBENT SOLUTION OF THE CURRENT PROBLEM IS IMPROVED,
C               XFIX IS USED TO STORE IN X THE COMPLETE INCUMBENT SOLUTION.
C   LAMUC = OPTIMAL MULTIPLIER OF THE FATHER NODE (=0 IF NO LAMUC IS KNOWN)
C   LUB = LAGRANGIAN UPPER BOUND OF THE FATHER NODE FOR THE CURRENT PROBLEM
C         (=0 IF NO BOUND IS KNOWN)
C   COMPUTE =  1 IF THE LAGRANGIAN BOUND MUST BE COMPUTED
C           =  0 IF THE LAGRANGIAN BOUND MUST NOT BE COMPUTED
C   CONS1OPT = 1 IF THE OPTIMAL SOLUTION MUST BE DETERMINED (BY PREPROC)
C                IN CASE ONE CONSTRAINT IS REDUNDANT
C            = 0 IF AN UPPER BOUND MUST BE DETERMINED (BY PREPROC)
C                IN CASE ONE CONSTRAINT IS REDUNDANT
C   FLSORTPW = 1 IF THE INSTANCE IS SORTED ACCORDING TO DECREASING PCOR/WCOR
C            = 0 OTHERWISE
C   FLAGPREP = 1 IF PREPROC HAS TO BE EXECUTED
C            = 0 IF PREPROC HAS NOT TO BE EXECUTED
C
C OUTPUT: CURRENT PROBLEM: NN, PP, WW, UU
C   LUB = LAGRANGIAN UPPER BOUND FOR THE CURRENT PROBLEM
C   LAMBDAU = OPTIMAL MULTIPLIER OF THE CURRENT PROBLEM (U RELAXED)
C   XLAGR   = SOLUTION VECTOR CORRESPONDING TO LAMBDAU FOR THE ORIGINAL PROBLEM
C         (CRITICAL ITEM = - 1 OR - 2, BUT 0 IF NEGATIVE MODIFIED PROFIT FOUND)
C   XLL    = SOLUTION VECTOR CORRESPONDING TO LAMBDAU FOR THE COMPACT PROBLEM
C         (CRITICAL ITEM = - 1 OR - 2, BUT 0 IF NEGATIVE MODIFIED PROFIT FOUND)
C   LAMUC = OPTIMAL MULTIPLIER OF THE CONTINUOUS RELAXATION OF THE
C           CURRENT PROBLEM (U RELAXED)
C   LAMWC = OPTIMAL MULTIPLIER OF THE CONTINUOUS RELAXATION OF THE
C           CURRENT PROBLEM (W RELAXED) BUT LAMWC = -1 IF LUB .LE. ZCOR
C   XC    = SOLUTION VECTOR CORRESPONDING TO LAMUC FOR THE ORIGINAL PROBLEM
C         (CRITICAL ITEM = - 1 OR - 2, BUT 0 IF NEGATIVE MODIFIED PROFIT FOUND)
C   XLLC  = SOLUTION VECTOR CORRESPONDING TO LAMUC FOR THE COMPACT PROBLEM
C         (CRITICAL ITEM = - 1 OR - 2, BUT 0 IF NEGATIVE MODIFIED PROFIT FOUND)
C   ZCOR = BEST SOLUTION VALUE FOUND (IF > ZCOR(INPUT)) FOR THE CURRENT PROBLEM
C   XFIX(J) = XFIX(J) INPUT, BUT = 0 FOR ITEMS WHICH CANNOT FIT
C   X    = SOLUTION VECTOR FOR THE ORIGINAL INSTANCE, PRODUCING ZCOR FOR THE
C          CURRENT INSTANCE, I.E., IZ1 + ZCOR FOR THE ORIGINAL INSTANCE.
C   XX      = BEST SOLUTION FOUND FOR THE CURRENT PROBLEM (NOT NECESSARILY
C             BETTER THAN ZCOR (INPUT))
C   JFEXE = 1 IF THE SUBROUTINE WAS COMPLETELY EXECUTED
C   COMPUTE =  1 IF THE BOUND WAS COMPUTED
C           =  0 IF NO BOUND WAS COMPUTED OR THE NODE WAS OPTIMALLY SOLVED
C   NITER = NUMBER OF LAGRANGIAN ITERATIONS
C   COMPACTOUT(J) = POSITION OF THE J-TH USEFUL ITEM
C                   IN THE ORIGINAL VECTORS PORIG, WORIG, UORIG (J=1,...,NN)
C
C NO SORTING IS ASSUMED FOR THE INPUT INSTANCE
C
C ON OUTPUT, IF ONE CONSTRAINT IS REDUNDANT THEN THE INSTANCE IS
C            SORTED ACCORDING TO THE EFFECTIVE CONSTRAINT,
C            OTHERWISE IT IS SORTED ACCORDING TO PP/WW
C
      IMPLICIT NONE
      INTEGER JDIM, COMPUTEINP, COMPUTE, NCOR, IP, LL,
     1        LLP1, J, LL1, LUB, LUBBIG, LIM, LIM1, IS, INF, MAXP, JJ,
     2        IS1, IBOUND, ISC,
     3        JFCRN, JFCRNL, JFCRNR, KK, K, KKM1, KKP1, JFEASOL,
     4        JFEASOLTRUE, KKK, JFLFSORT, KCHSN, KDHSN, ISCALE, J1, J2
      REAL    A , B
      INTEGER LAMUC, LAMWC, LLEFT, LRIGHT, LAMBDAOLD, NLAM, KVAR
      INTEGER IPN, IUBMT, IUBMT1, INSTEP, DELTA, KP1, KM1
      INTEGER PCOR(JDIM),WCOR(JDIM),UCOR(JDIM),XC(JDIM)
      INTEGER LAMBDAU,XLAGR(JDIM),XLL(JDIM)
      INTEGER X(JDIM)
      INTEGER N,XFIX(JDIM)
      INTEGER PP(JDIM),WW(JDIM),UU(JDIM),XLLC(JDIM)
      INTEGER XX(JDIM),COMPACTIN(JDIM),COMPACTOUT(JDIM),NN,JSTART
      INTEGER PORIG(JDIM),WORIG(JDIM),UORIG(JDIM)
      DOUBLE PRECISION RAT(10002)
      INTEGER POINT(10002)
      INTEGER ZCOR, ZBIG
      INTEGER CH,DH,CHS,CHSN,RESUG,RESWG,SUMPG
      REAL    SUMUBOUND,SUMUN,WUU(10002)
      INTEGER PBAR(10002), XLLEFT(10002), XLRIGHT(10002)
      INTEGER PPS,UUS,WWS,SUMUS,ISUMUN,XRES(10002)
      INTEGER NITER, CONS1OPT, FLSORTPW
      INTEGER SUMW, SUMU, MAXW, MAXU, FLAGPREP, MINW, MINU, JJJ
      INTEGER MAXL, LEVL, II
C*******************************
C      IF ( LAMUC .EQ. 0 ) WRITE (6,3726) NCOR, LAMUC
C 3726 FORMAT(' NCOR, LAMUC',2I5)
C*******************************
C
C P A R T    O N E  ( I N I T I A L I Z A T I O N)
C
C
C PREPROCESSING
C
C ELIMINATE USELESS ITEMS.
C DEFINE COMPACTOUT(J) = POSITION OF THE J-TH USEFUL ITEM
C                        IN THE ORIGINAL VECTORS (J=1,...,NN)
C THE COMPACT VERSION OF
C     PCOR,WCOR,UCOR,ZCOR,       LUB,          XC,  XLAGR     IS
C     PP,  WW,  UU  ,ZBIG/ISCALE,LUBBIG/ISCALE,XLLC,XLL
C WITH PP AND PCOR MULTIPLIED BY ISCALE
C
C IF THE RESULTING PROBLEM IS TRIVIAL OR ONLY ONE CONSTRAINT IS ACTIVE, THEN
C    PERFORM THE COMPUTATION,
C    STORE THE BEST SOLUTION FOUND FOR THE CURRENT PROBLEM IN ZBIG AND XX,
C    AND SET NN = - NN (SO POSTPROC AND RETURN WILL FOLLOW)
C ELSE
C    NN IS POSITIVE;
C    EXECUTION WILL STORE THE BEST SOLUTION FOUND FOR THE CURRENT PROBLEM
C    IN ZBIG AND XX
C IN BOTH CASES, POSTPROC WILL MODIFY ZCOR ONLY IF ZBIG IS BETTER,
C STORING IN THE CORRECT POSITIONS OF X THE CORRESPONDING SOLUTION.
      LUBBIG = LUB*ISCALE
C CHEK FOR PREPROC EXECUTION
      IF ( FLAGPREP .EQ. 1 ) GO TO 2
C PREPROC NOT EXECUTED
      IF ( COMPUTE .EQ. 0 ) RETURN
      GO TO 4
    2 CALL PREPROC9(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,JDIM,FLSORTPW,
     1              CONS1OPT,ISCALE,COMPACTIN,PORIG,WORIG,UORIG,
     2              LAMUC,RAT,NN,PP,WW,UU,LUBBIG,ZBIG,XX,XFIX,XLLC,
     3              COMPACTOUT,LAMWC,LAMUC,INF,PBAR,XLLEFT,XLRIGHT)
C
      JSTART = 1
      LAMBDAU = LAMUC
      IF ( NN .EQ. NCOR .AND. COMPUTE .EQ. 0 ) RETURN
      COMPUTE = 1
      DO 3 J=1,NN
        XLL(J) = XLLC(J)
    3 CONTINUE
      IF ( NN .LE. 0 ) GO TO 1000
C
C INITIALIZE
C
    4 COMPUTEINP = COMPUTE
      COMPUTE = 0
      LAMWC = - 1
      NITER = 0
      INSTEP = 0
      PP(NN+1) = 0
      PBAR(NN+1) = 0
      WW(NN+1) = CH
      JFLFSORT = 0
      ZBIG = 0
      JFCRNL = 1
      DO 6 J=1,NN
        POINT(J) = J
        IF ( UU(J) .GT. 0 ) GO TO 5
        WUU(J) = CH + WW(J)
        GO TO 6
    5   WUU(J) = FLOAT(WW(J))/UU(J)
    6 CONTINUE
      IF ( LAMUC .NE. 0 ) GO TO 310
C COMPUTE THE DANTZIG BOUND WITH ORIGINAL SORTING (I.E., FOR LAMUC=0)
      IP = 0
      CHS = CH
      SUMUBOUND = 0
      DO 8 LL=1,NN
        IF ( WW(LL) .GT. CHS ) GO TO 10
        IP = IP + PP(LL)
        SUMUBOUND = SUMUBOUND + UU(LL)
        CHS = CHS - WW(LL)
        XLLC(LL) = 1
        XLL(LL) = 1
        XRES(LL) = 1
    8 CONTINUE
      STOP 999
   10 SUMUS = SUMUBOUND
      XLLC(LL) = -1
      XLL(LL) = -1
      LLP1 = LL + 1
      DO 15 J=LLP1,NN
        XLLC(J) = 0
        XLL(J) = 0
   15 CONTINUE
C CHECK IF THE CONTINUOUS UPPER BOUND CANNOT BE IMPROVED BY LAGRANGIAN REL.
C WW(LL) > 0 SINCE LL IS CRITICAL
      SUMUBOUND = SUMUBOUND + DBLE(CHS)/WW(LL)*UU(LL)
      LL = LL - 1
      IF ( SUMUS .LE. DH ) GO TO 30
C COMPUTE A GREEDY SOLUTION FOR ITEMS 1, ..., LL
      SUMPG = 0
      RESWG = CH
      RESUG = DH
      DO 25 J=1,LL
        IF ( WW(J) .GT. RESWG ) GO TO 20
        IF ( UU(J) .GT. RESUG ) GO TO 20
        XRES(J) = 1
        SUMPG = SUMPG + PP(J)
        RESWG = RESWG - WW(J)
        RESUG = RESUG - UU(J)
        GO TO 25
   20   XRES(J) = 0
   25 CONTINUE
      GO TO 35
   30 SUMPG = IP
      RESWG = CHS
      RESUG = DH - SUMUS
C COMPLETE THE GREEDY SOLUTION WITH ITEMS LL+1, ..., NN
   35 LL1 = LL + 1
      DO 40 J=LL1,NN
        IF ( WW(J) .GT. RESWG ) GO TO 38
        IF ( UU(J) .GT. RESUG ) GO TO 38
        XRES(J) = 1
        SUMPG = SUMPG + PP(J)
        RESWG = RESWG - WW(J)
        RESUG = RESUG - UU(J)
        GO TO 40
   38   XRES(J) = 0
   40 CONTINUE
      ZBIG = SUMPG
      DO 45 J=1,NN
        XX(J) = XRES(J)
   45 CONTINUE
   60 IF ( CHS .GT. 0 ) GO TO 65
      IF ( SUMUS .GT. DH ) GO TO 65
      LUBBIG = IP
C OPTIMAL SOLUTION
C LAMUC(OUTPUT) = LAMBDAU(OUTPUT) = 0
C LAMWC(OUTPUT) FICTITIOUS
      LAMUC = 0
      LAMBDAU = 0
      GO TO 1000
C WW(LL), WW(LL+1) AND WW(LL+2) > 0
   65 LIM = IP + CHS*DBLE(PP(LL+2))/WW(LL+2)
      A = WW(LL+1) - CHS
      B = IP + PP(LL+1)
      LIM1 = B - A*DBLE(PP(LL))/WW(LL)
      IF ( LIM1 .GT. LIM ) LIM = LIM1
C IF NO BOUND IS GIVEN, LIM MUST BE THE BOUND
      IF ( LUB .EQ. 0 ) LUBBIG = LIM + 1
      IF ( LIM .LT. LUBBIG ) LUBBIG = LIM
C      WRITE (6,999) LIM, SUMUBOUND, DH
  999 FORMAT (' LIM, SUMUBOUND, DH', I10,F10.3,I10)
      IF ( LUBBIG/ISCALE*ISCALE .LE. ZBIG ) GO TO 80
      IF ( LUBBIG/ISCALE .GT. ZCOR ) GO TO 100
C OPTIMAL SOLUTION
C LAMUC(OUTPUT) = LAMBDAU(OUTPUT) = 0
C LAMWC(OUTPUT) FICTITIOUS
   80 LAMUC = 0
      LAMBDAU = 0
      GO TO 1000
  100 IF ( SUMUBOUND .GT. DH ) GO TO 200
C THE U CONSTRAINT IS REDUNDANT FOR THE CONTINUOUS RELAXATION, HENCE
C LAMUC(OUTPUT) = LAMBDAU(OUTPUT) = 0
C LAMWC(OUTPUT) MUST BE DETERMINED
      LAMUC = 0
      LAMWC = PP(LL+1)/WW(LL+1)
      LAMBDAU = 0
      GO TO 1000
C
C P A R T   T W O  ( L A G R A N G I A N   B O U N D )
C
C CHECK FOR EXECUTION
  200 IF ( COMPUTEINP .EQ. 0 ) GO TO 1000
      JFCRNL = 1
      DO 210 J=1,NN
        XLLEFT(J) = XLLC(J)
  210 CONTINUE
      COMPUTE = 1
      IS = LL + 1
      IF ( LAMUC .GT. 0 ) GO TO 310
C NO LAMUC IS GIVEN IN INPUT
C DETERMINE THE LAMUC VALUE PRODUCING THE MINIMUM LAGRANGIAN BOUND
C
C INITIAL LAMUC VALUE: MAXIMUM LAMUC WHICH DOES NOT CHANGE THE
C CRITICAL ITEM IS = LL + 1
      LLEFT = INF
      LRIGHT = 0
      PPS = PP(IS)
      WWS = WW(IS)
      UUS = UU(IS)
      DO 270 J=1,LL
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR > 0
        IF ( UU(J)*WWS .LE. WW(J)*UUS ) GO TO 270
        KVAR= ( DBLE(PP(J))*WWS - DBLE(PPS)*WW(J) ) /
     1                             ( UU(J)*WWS - WW(J)*UUS )
        IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  270 CONTINUE
      IF ( UUS .EQ. 0 ) GO TO 275
      KVAR= DBLE(PPS)/DBLE(UUS)
      IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  275 IS1 = IS + 1
      DO 280 J=IS1,NN
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR < 0
        IF ( UU(J)*WWS .GE. WW(J)*UUS ) GO TO 280
        KVAR = ( DBLE(PPS)*WW(J) - DBLE(PP(J))*WWS ) /
     1                              ( UUS*WW(J) - UU(J)*WWS )
        IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  280 CONTINUE
C IP + LLEFT*(DH - SUMUS) = SUM OF THE FIRST PBAR VALUES
C (UNTIL CRITICAL ITEM EXCLUDED) FOR THE FIRST LAMUC (=LLEFT)
C PPS - LLEFT*UUS = PBAR OF THE CRITICAL ITEM FOR LAMUC (=LLEFT)
C WWS > 0 (WEIGHT OF THE CRITICAL ITEM)
      IBOUND = IP + LLEFT*(DH - SUMUS) +
     1                CHS*DBLE(PPS - LLEFT*UUS)/WWS
      IF ( IBOUND .GE. LUBBIG ) GO TO 300
C BETTER BOUND
      LUBBIG = IBOUND
      LAMBDAU = LLEFT
C XLL HAS THE INITIAL VALUE (= XLLC)
  300 LAMUC = LLEFT
      IF ( LUBBIG/ISCALE*ISCALE .LE. ZBIG ) GO TO 1000
      IF ( LUBBIG/ISCALE .LE. ZCOR ) GO TO 1000
      NLAM = LLEFT + 1
      INSTEP = NLAM
      GO TO 320
C A LAMUC VALUE IS GIVEN IN INPUT
  310 IF ( COMPUTEINP .EQ. 0 ) GO TO 1000
      COMPUTE = 1
      NLAM = LAMUC
      LLEFT = 0
      LRIGHT = 0
C
C NEW BOUND
C
  320 NITER = NITER + 1
      IF ( II/LEVL*LEVL .NE. II .AND. NITER .GT. MAXL ) GO TO 1000
      DO 340 J=1,NN
        PBAR(J) = PP(J) - NLAM*UU(J)
        IF ( PBAR(J) .GT. 0 ) GO TO 325
        RAT(J) = 0
        GO TO 340
  325   IF ( WW(J) .GT. 0 ) GO TO 330
        RAT(J) = LUBBIG + DBLE(PBAR(J))/DBLE(UU(J))
        GO TO 340
  330   RAT(J) = DBLE(PBAR(J))/DBLE(WW(J))
  340 CONTINUE
      IF ( JFLFSORT .EQ. 1 ) GO TO 342
      CALL SORTRDRD(NN,RAT,POINT,JDIM,WUU)
      JFLFSORT = 1
      GO TO 344
  342 CALL SHUTTLERDRD(NN,RAT,POINT,JDIM,WUU)
  344 IPN = DH*NLAM
      JFEASOL = 0
      CHSN = CH
      ISUMUN = 0
      JFCRN = 1
C JFCRN .EQ. -1 IF THE CRITICAL ITEM HAS NONPOSITIVE PROFIT
      DO 350 KK=1,NN
        K = POINT(KK)
        IF ( PBAR(K) .LE. 0 ) GO TO 360
        IF ( WW(K) .GT. CHSN ) GO TO 370
        IPN = IPN + PBAR(K)
        JFEASOL = JFEASOL + PP(K)
        CHSN = CHSN - WW(K)
        ISUMUN = ISUMUN + UU(K)
        XRES(K) = 1
  350 CONTINUE
C NEGATIVE MODIFIED PROFIT FOUND
  360 IUBMT = IPN
      SUMUN = ISUMUN
      JFCRN = - 1
      GO TO 380
  370 KM1 = POINT(KK-1)
      KP1 = POINT(KK+1)
      IF ( PBAR(KP1) .LT. 0 ) PBAR(KP1) = 0
C WW(K), WW(KP1), WW(KM1) > 0
      SUMUN = ISUMUN + FLOAT(CHSN)*UU(K)/WW(K)
      IUBMT = IPN + CHSN*RAT(KP1)
      A = WW(K) - CHSN
      B = IPN + PBAR(K)
      IUBMT1 = B - A*RAT(KM1)
      IF ( IUBMT1 .GT. IUBMT ) IUBMT = IUBMT1
  380 KKM1 = KK - 1
      KKP1 = KK + 1
C UPDATE LUBBIG (ALSO IF EQUAL)
      IF ( IUBMT .GT. LUBBIG ) GO TO 390
      LUBBIG = IUBMT
      LAMUC = NLAM
      LAMBDAU = NLAM
      DO 383 J=1,NN
        XLL(J) = 0
  383 CONTINUE
      DO 386 JJ=1,KKM1
        J = POINT(JJ)
        XLL(J) = 1
  386 CONTINUE
      IF ( JFCRN .GE. 0 ) XLL(POINT(KK)) = -1
      IF ( LUBBIG/ISCALE*ISCALE .LE. ZBIG ) GO TO 1000
      IF ( LUBBIG/ISCALE .LE. ZCOR ) GO TO 1000
C UPDATE THE CURRENT OPTIMAL SOLUTION
  390 JFEASOLTRUE = JFEASOL
      IF ( ISUMUN .LE. DH ) GO TO 400
C COMPUTE A GREEDY SOLUTION FOR ITEMS POINT(1), ..., POINT(KK-1)
      SUMPG = 0
      RESWG = CH
      RESUG = DH
      DO 395 JJ=1,KKM1
        J = POINT(JJ)
        IF ( WW(J) .GT. RESWG ) GO TO 393
        IF ( UU(J) .GT. RESUG ) GO TO 393
        XRES(J) = 1
        SUMPG = SUMPG + PP(J)
        RESWG = RESWG - WW(J)
        RESUG = RESUG - UU(J)
        GO TO 395
  393   XRES(J) = 0
  395 CONTINUE
      GO TO 405
  400 SUMPG = JFEASOL
      RESWG = CHSN
      RESUG = DH - ISUMUN
C COMPLETE THE GREEDY SOLUTION WITH ITEMS POINT(KK), ..., POINT(NN)
  405 JJ = KK - 1
      IF ( MINW .GT. RESWG .OR. MINU .GT. RESUG ) GO TO 416
      DO 415 JJ=KK,NN
        J = POINT(JJ)
        IF ( WW(J) .GT. RESWG ) GO TO 410
        IF ( UU(J) .GT. RESUG ) GO TO 410
        XRES(J) = 1
        SUMPG = SUMPG + PP(J)
        RESWG = RESWG - WW(J)
        RESUG = RESUG - UU(J)
        IF ( MINW .GT. RESWG .OR. MINU .GT. RESUG ) GO TO 416
        GO TO 415
  410   XRES(J) = 0
  415 CONTINUE
      GO TO 418
  416 DO 417 JJJ=JJ+1,NN
        J = POINT(JJJ)
        XRES(J) = 0
  417 CONTINUE
  418 IF ( SUMPG/ISCALE*ISCALE .LE. ZBIG ) GO TO 440
      ZBIG = SUMPG
      DO 420 J=1,NN
        XX(J) = XRES(J)
  420 CONTINUE
      IF ( ZBIG .GE. LUBBIG/ISCALE*ISCALE ) GO TO 1000
      IF ( ZCOR .GE. LUBBIG/ISCALE ) GO TO 1000
  440 ISC = POINT(KKM1+1)
      PPS = PP(ISC)
      WWS = WW(ISC)
      UUS = UU(ISC)
      IF ( SUMUN .LE. DH ) GO TO 530
C CASE 1: THE UU CONSTRAINT IS VIOLATED
C XLLEFT = SOLUTION VECTOR CORRESPONDING TO THE LAST LLEFT VALUE
      JFCRNL = JFCRN
      DO 443 J=1,NN
        XLLEFT(J) = 0
  443 CONTINUE
      DO 446 JJ=1,KKM1
        J = POINT(JJ)
        XLLEFT(J) = 1
  446 CONTINUE
      IF ( JFCRN .GE. 0 ) XLLEFT(POINT(KK)) = -1
      IF ( JFCRN .EQ. 1 ) GO TO 460
C CASE 1)B): THE UU CONSTRAINT IS VIOLATED AND NEGATIVE PBAR
C FIND THE MAXIMUM LAMUC WHICH DOES NOT CHANGE THE CURRENT
C CRITICAL ITEM POINT(KKM1+1)
C UU CONSTRAINT VIOLATED --> SOME UU(J) IS > 0
      LAMBDAOLD = NLAM
      LLEFT = INF
      DO 450 JJ=1,KKM1
        J = POINT(JJ)
        IF ( UU(J) .EQ. 0 ) GO TO 450
        IF ( FLOAT(PP(J))/UU(J) .LT. LLEFT )
     1                    LLEFT = FLOAT(PP(J))/UU(J)
  450 CONTINUE
      NLAM = LLEFT
      GO TO 510
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
C REGULAR CASE
C CASE 1)A): THE UU CONSTRAINT IS VIOLATED AND NO NEGATIVE PBAR
C FIND THE MAXIMUM LAMUC WHICH DOES NOT CHANGE THE CURRENT
C CRITICAL ITEM POINT(KKM1+1)
  460 LAMBDAOLD = NLAM
      LLEFT = INF
      DO 470 JJ=1,KKM1
        J = POINT(JJ)
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR > 0
        IF ( UU(J)*WWS .LE. WW(J)*UUS ) GO TO 470
        KVAR= ( DBLE(PP(J))*WWS - DBLE(PPS)*WW(J) ) /
     1                             ( UU(J)*WWS - WW(J)*UUS )
        IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  470 CONTINUE
      IF ( UUS .EQ. 0 ) GO TO 475
      KVAR= DBLE(PPS)/DBLE(UUS)
      IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  475 DO 480 JJ=KKP1,NN
        J = POINT(JJ)
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR < 0
        IF ( UU(J)*WWS .GE. WW(J)*UUS ) GO TO 480
        KVAR = ( DBLE(PPS)*WW(J) - DBLE(PP(J))*WWS ) /
     1                              ( UUS*WW(J) - UU(J)*WWS )
        IF ( KVAR .LT. LLEFT ) LLEFT = KVAR
  480 CONTINUE
C PROBABLY USELESS
  485 IF ( LLEFT .LT. LAMBDAOLD ) LLEFT = LAMBDAOLD
C UPDATE LUBBIG
C JFEASOLTRUE + LLEFT*(DH - ISUMUN) = SUM OF THE FIRST PBAR VALUES
C (UNTIL CRITICAL ITEM EXCLUDED) FOR THE NEW LAMUC (=LLEFT)
C PPS - LLEFT*UUS = PBAR OF THE CRITICAL ITEM FOR THE NEW LAMUC (=LLEFT)
C WWS > 0 (WEIGHT OF THE CRITICAL ITEM)
      IBOUND = JFEASOLTRUE + LLEFT*(DH - ISUMUN) +
     1                CHSN*DBLE(PPS - LLEFT*UUS)/WWS
      IF ( IBOUND .GE. LUBBIG ) GO TO 510
      LUBBIG = IBOUND
      LAMUC = LLEFT
      LAMBDAU = LLEFT
      IF ( LUBBIG/ISCALE*ISCALE .LE. ZBIG ) GO TO 1000
      IF ( LUBBIG/ISCALE .LE. ZCOR ) GO TO 1000
      DO 490 J=1,NN
        XLLC(J) = 0
        XLL(J) = 0
  490 CONTINUE
      DO 500 JJ=1,KKM1
        J = POINT(JJ)
        XLLC(J) = 1
        XLL(J) = 1
  500 CONTINUE
      IF ( JFCRN .GE. 0 ) XLLC(POINT(KKM1+1)) = -1
      IF ( JFCRN .GE. 0 ) XLL(POINT(KKM1+1)) = -1
  510 CONTINUE
      IF ( LRIGHT .GT. 0 ) GO TO 630
      IF ( INSTEP .GT. 0 ) GO TO 520
      INSTEP = (LLEFT - NLAM )/2
      IF ( INSTEP .EQ. 0 ) INSTEP = 1
  520 INSTEP = 2*INSTEP
      NLAM = LLEFT + INSTEP
      GO TO 320
C END OF CASE 1
C
C CASE 2: THE UU CONSTRAINT IS SATISFIED
C XLRIGHT = SOLUTION VECTOR CORRESPONDING TO THE LAST LRIGHT VALUE
  530 JFCRNR = JFCRN
      DO 533 J=1,NN
        XLRIGHT(J) = 0
  533 CONTINUE
      DO 536 JJ=1,KKM1
        J = POINT(JJ)
        XLRIGHT(J) = 1
  536 CONTINUE
      IF ( JFCRN .GE. 0 ) XLRIGHT(POINT(KK)) = -2
      LRIGHT = 0
      IF ( NLAM .EQ. 0 ) GO TO 640
C      IF ( SUMUN .EQ. DH ) GO TO 640
      IF ( JFCRN .EQ. 1 ) GO TO 550
C CASE 2)B): THE UU CONSTRAINT IS SATISFIED AND NEGATIVE PBAR.
C FIND THE MINIMUM LAMUC WHICH DOES NOT CHANGE THE CURRENT
C CRITICAL ITEM POINT(KKM1+1)
C ALL ITEMS FOLLOWING KK HAVE PBAR < 0 --> NO UU IS = 0
      LAMBDAOLD = NLAM
      LRIGHT = 0
      KK = KKM1 + 1
      DO 540 JJ=KK,NN
        J = POINT(JJ)
        KVAR = FLOAT(PP(J))/UU(J) + 0.999999
        IF ( KVAR .GT. LRIGHT ) LRIGHT = KVAR
  540 CONTINUE
C PROBABLY USELESS
      IF ( LRIGHT .GT. LAMBDAOLD ) LRIGHT = LAMBDAOLD
      NLAM = LRIGHT
      DELTA = LAMBDAOLD - LRIGHT
      GO TO 610
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
C REGULAR CASE
C CASE 2)A): THE UU CONSTRAINT IS SATISFIED AND NO NEGATIVE PBAR.
C FIND THE MINIMUM LAMUC WHICH DOES NOT CHANGE THE CURRENT
C CRITICAL ITEM POINT(KKM1+1)
  550 LAMBDAOLD = NLAM
      LRIGHT = 0
      ISC = POINT(KKM1+1)
      PPS = PP(ISC)
      WWS = WW(ISC)
      UUS = UU(ISC)
      DO 560 JJ=1,KKM1
        J = POINT(JJ)
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR > 0
        IF ( UU(J)*WWS .GE. WW(J)*UUS ) GO TO 560
        KVAR= ( DBLE(PPS)*WW(J) - DBLE(PP(J))*WWS ) /
     1        ( UUS*WW(J) - WWS*UU(J) ) + 0.999999
        IF ( KVAR .GT. LRIGHT ) LRIGHT = KVAR
  560 CONTINUE
      DO 570 JJ=KKP1,NN
        J = POINT(JJ)
C THE FOLLOWING CHECK ALSO ENSURES DENOMINATOR > 0
        IF ( UU(J)*WWS .LE. WW(J)*UUS ) GO TO 570
        KVAR = ( DBLE(PP(J))*WWS - DBLE(PPS)*WW(J) ) /
     1         ( UU(J)*WWS - UUS*WW(J) ) + 0.999999
        IF ( KVAR .GT. LRIGHT ) LRIGHT = KVAR
  570 CONTINUE
C PROBABLY USELESS
  585 IF ( LRIGHT .GT. LAMBDAOLD ) LRIGHT = LAMBDAOLD
C UPDATE LUBBIG
      DELTA = LAMBDAOLD - LRIGHT
C UPDATE LUBBIG
C JFEASOLTRUE + LRIGHT*(DH - ISUMUN) = SUM OF THE FIRST PBAR VALUES
C (UNTIL CRITICAL ITEM EXCLUDED) FOR THE NEW LAMUC (=LRIGHT)
C PPS - LRIGHT*UUS = PBAR OF THE CRITICAL ITEM FOR THE NEW LAMUC (=LRIGHT)
C WWS > 0 (WEIGHT OF THE CRITICAL ITEM)
      IBOUND = JFEASOLTRUE + LRIGHT*(DH - ISUMUN) +
     1                CHSN*DBLE(PPS - LRIGHT*UUS)/WWS
      IF ( IBOUND .GE. LUBBIG ) GO TO 610
      LUBBIG = IBOUND
      LAMUC = LRIGHT
      LAMBDAU = LRIGHT
      IF ( LUBBIG/ISCALE*ISCALE .LE. ZBIG ) GO TO 1000
      IF ( LUBBIG/ISCALE .LE. ZCOR ) GO TO 1000
      DO 590 J=1,NN
        XLLC(J) = 0
        XLL(J) = 0
  590 CONTINUE
      DO 600 JJ=1,KKM1
        J = POINT(JJ)
        XLLC(J) = 1
        XLL(J) = 1
  600 CONTINUE
      IF ( JFCRN .GE. 0 ) XLLC(POINT(KKM1+1)) = -1
      IF ( JFCRN .GE. 0 ) XLL(POINT(KKM1+1)) = -1
  610 IF ( LLEFT .GT. 0 ) GO TO 630
      IF ( INSTEP .GT. 0 ) GO TO 620
      INSTEP = DELTA/2
      IF ( INSTEP .EQ. 0 ) INSTEP = 1
  620 INSTEP = 2*INSTEP
      NLAM = LRIGHT - INSTEP
      IF ( NLAM .LT. 0 ) NLAM = 0
      GO TO 320
C NEW LAMUC AND ITERATE
  630 NLAM = (LLEFT + LRIGHT)/2
      IF ( NLAM .GT. LLEFT ) GO TO 320
      IF ( SUMUN .GT. DH ) GO TO 700
C FOR THE CURRENT LAMBDA (=LRIGHT) THE UU CONSTRAINT IS NOT VIOLATED
  640 LAMUC = LRIGHT
      DO 650 J=1,NN
        XLLC(J) = XLRIGHT(J)
  650 CONTINUE
      IF ( LRIGHT .GT. 0 ) GO TO 750
C FOR THE CURRENT LAMBDA (= LRIGHT = 0) THE UU CONSTRAINT IS NOT VIOLATED
      LAMWC = PPS/WWS
      GO TO 1000
C FOR THE CURRENT LAMBDA (=LLEFT) THE UU CONTSRAINT IS VIOLATED
  700 LAMUC = LLEFT
      DO 720 J=1,NN
        XLLC(J) = XLLEFT(J)
  720 CONTINUE
C DETERMINE LAMWC
C IF NEGATIVE PROFIT FOUND FOR LAMUC THEN LAMWC = 0
  750 LAMWC = 0
      IF ( JFCRNL .LT. 0 .OR. JFCRNR .LT. 0 ) GO TO 1000
C IF NO NEGATIVE PROFIT FOUND FOR LAMUC THEN DETERMINE LAMWC
C THROUGH THE CRITICAL ITEMS IN XLLEFT AND XLRIGHT (IF DIFFERENT) OR
C THROUGH THE PAIR OF DIFFERENT SOLUTION ELEMENTS IN XLLEFT AND XLRIGHT
      J1 = -1
      J2 = -1
      DO 780 J=1,NN
        IF ( XLLEFT(J) .LT. 0 ) THEN
          J1 = J
          IF ( J2 .GT. 0 ) GO TO 790
        ENDIF
        IF ( XLRIGHT(J) .LT. 0 ) THEN
          J2 = J
          IF ( J1 .GT. 0 ) GO TO 790
        ENDIF
  780 CONTINUE
  790 CONTINUE
      IF ( J1 .LT. 0 .OR. J2 .LT. 0 ) WRITE (6,788)
  788 FORMAT (' &&&&&&&&&&&&&&&&&&&&&& MENO DI 2 DIVERSI &&&&&&&&&&')
      IF ( J1 .LT. 0 .OR. J2 .LT. 0 ) READ (5,766) JFCRN
  766 FORMAT (I5)
      IF ( J1 .NE. J2 ) GO TO 850
C SAME CRITICAL ITEM
      DO 800 J=1,NN
        IF ( XLLEFT(J) .EQ. XLRIGHT(J) ) GO TO 800
        IF ( J .EQ. J1 ) GO TO 800
        J2 = J
        GO TO 850
  800 CONTINUE
      WRITE (6,788)
      READ (5,766) JFCRN
  850 IF (DBLE(WW(J1))*UU(J2) .NE. DBLE(WW(J2))*UU(J1)) THEN
        LAMWC = (DBLE(PP(J1))*UU(J2) - DBLE(PP(J2))*UU(J1))
     1                                   /
     2          (DBLE(WW(J1))*UU(J2) - DBLE(WW(J2))*UU(J1))
      ELSE
        LAMWC = LAMUC
      ENDIF
      IF ( LAMWC .LT. 0 ) LAMWC = LAMUC
C TERMINATE
 1000 IF ( NN .LT. 0 ) NN = - NN
      CALL POSTPROC7(NN,LUBBIG,ZBIG,XX,XLL,XLLC,COMPACTIN,COMPACTOUT,
     1            ISCALE,JDIM,NCOR,LUB,ZCOR,N,X,XFIX,XLAGR,XC,JSTART)
      RETURN
      END
      SUBROUTINE PREPROC9(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,JDIM,FLSORTPW,
     1             CONS1OPT,ISCALE,COMPACTIN,PORIG,WORIG,UORIG,LAMUC,
     2             RAT,NN,PP,WW,UU,LUBBIG,ZBIG,XX,XFIX,XLL,COMPACTOUT,
     3             LAMBDAW,LAMBDAU,INF,DUMMY1,DUMMY2,DUMMY3)
C
C PREPROCESSING
C
C ELIMINATE USELESS ITEMS.
C DEFINE COMPACTOUT(J) = POSITION OF THE J-TH USEFUL ITEM
C                        IN THE ORIGINAL VECTORS (J=1,...,NN)
C SCALE THE PROFIT VECTOR.
C IF THE RESULTING PROBLEM IS TRIVIAL, PERFORM THE COMPUTATION
C    (SOLUTION STORED IN XX, LAGRANGIAN SOLUTION IN XLL)
C    AND SET NN = - NN
C
C IF ONE CONSTRAINT IS REDUNDANT THEN
C    IF CONS1OPT = 1 THEN EXACTLY SOLVE THE RESULTING 0-1 KP,
C                         (SOLUTION STORED IN XX)
C    IF CONS1OPT = 0 THEN COMPUTE A BOUND FOR THE RESULTING 0-1 KP
C                   (SOLUTION STORED IN XX, LAGRANGIAN SOLUTION IN XLL)
C
C IF FLSORTPW =1 THEN THE INPUT INSTANCE IS SORTED ACCORDING TO
C                DECREASING PCOR/WCOR RATIOS
C
C ON OUTPUT, IF ONE CONSTRAINT IS REDUNDANT THEN THE INSTANCE IS
C               SORTED ACCORDING TO THE EFFECTIVE CONSTRAINT,
C            OTHERWISE IT IS SORTED ACCORDING TO PP/WW
      IMPLICIT NONE
      INTEGER JDIM, NCOR, LUBBIG, ISCALE, LAMUC, ZCOR
      INTEGER PCOR(JDIM),WCOR(JDIM),UCOR(JDIM)
      INTEGER PP(JDIM),WW(JDIM),UU(JDIM),XLL(JDIM)
      INTEGER XX(JDIM),XFIX(JDIM),COMPACTIN(JDIM),COMPACTOUT(JDIM),NN
      INTEGER PORIG(JDIM),WORIG(JDIM),UORIG(JDIM)
      DOUBLE PRECISION RAT(JDIM)
      INTEGER ZBIG,ZCORBIG
      INTEGER CH,DH, CONS1OPT,FLSORTPW
      INTEGER I,J,K,LL
C      INTEGER SUMP,SUMW,SUMU,IP,CHS
      INTEGER INF,SUMW,SUMU,IP,CHS
      INTEGER LAMBDAW,LAMBDAU
      INTEGER DUMMY1(JDIM),DUMMY2(JDIM),DUMMY3(JDIM)
      INTEGER MINU,MIN2U,MINW,MIN2W,MAXP,JMAXP
      NN = 0
      INF = 1000000000
C      SUMP = 0
      SUMW = 0
      SUMU = 0
      MINU = INF
      MIN2U = INF
      MINW = INF
      MIN2W = INF
      MAXP = 0
      DO 10 J=1,NCOR
        IF ( WCOR(J) .GT. CH ) GO TO 8
        IF ( UCOR(J) .GT. DH ) GO TO 8
        NN = NN + 1
        PP(NN) = PCOR(J)
        IF ( PP(NN) .GT. MAXP ) THEN
          MAXP = PP(NN)
          JMAXP = NN
        ENDIF
        WW(NN) = WCOR(J)
        UU(NN) = UCOR(J)
C        SUMP = SUMP + PP(NN)
        SUMW = SUMW + WW(NN)
        SUMU = SUMU + UU(NN)
        COMPACTOUT(NN) = COMPACTIN(J)
        IF ( WW(NN) .LT. MIN2W ) THEN
          IF ( WW(NN) .LT. MINW ) THEN
            MIN2W = MINW
            MINW = WW(NN)
          ELSE
            MIN2W = WW(NN)
          ENDIF
        ENDIF
        IF ( UU(NN) .LT. MIN2U ) THEN
          IF ( UU(NN) .LT. MINU ) THEN
            MIN2U = MINU
            MINU = UU(NN)
          ELSE
            MIN2U = UU(NN)
          ENDIF
        ENDIF
        GO TO 10
    8   XFIX(COMPACTIN(J)) = 0
   10 CONTINUE
      IF ( NN .GT. 2 ) GO TO 100
C OPTIMAL SOLUTION
C LAMBDAU(OUTPUT) = 0
C LAMBDAW(OUTPUT) FICTITIOUS
      LAMBDAU = 0
      LAMBDAW = -1
C SPECIAL CASES NN .LE. 2
      IF ( NN .GT. 0 ) GO TO 20
C  1) NN = 0
      LUBBIG = 0
      ZBIG = LUBBIG
      RETURN
   20 IF ( NN .GT. 1 ) GO TO 30
C  2) NN = 1
      LUBBIG = PP(1)
      ZBIG = LUBBIG
      XX(1) = 1
      XLL(1) = 1
      NN = -1
      RETURN
   30 CONTINUE
C  3) NN = 2
      IF ( SUMW .LE. CH .AND. SUMU .LE. DH ) GO TO 50
C  ONLY ONE FITS
      I = 1
      IF ( PP(2) .GT. PP(1) ) I = 2
      LUBBIG = PP(I)
      ZBIG = LUBBIG
      XX(I) = 1
      XLL(I) = 1
      XX(3-I) = 0
      XLL(3-I) = 0
      NN = -2
      RETURN
C  BOTH FIT
   50 LUBBIG = PP(1) + PP(2)
      ZBIG = LUBBIG
      XX(1) = 1
      XLL(1) = 1
      XX(2) = 1
      XLL(2) = 1
      NN = - 2
      RETURN
  100 IF ( SUMW .GT. CH .OR. SUMU .GT. DH ) GO TO 200
C SPECIAL CASE: ALL ITEMS FIT
      LUBBIG = 0
      DO 110 K=1,NN
        LUBBIG = LUBBIG + PP(K)
        XX(K) = 1
        XLL(K) = 1
  110 CONTINUE
      ZBIG = LUBBIG
      NN = - NN
C OPTIMAL SOLUTION
C LAMBDAU(OUTPUT) = 0
C LAMBDAW(OUTPUT) FICTITIOUS
      LAMBDAU = 0
      LAMBDAW = -1
      RETURN
  200 IF ( MINW + MIN2W .GT. CH .OR. MINU + MIN2U .GT. DH ) THEN
C ONLY ONE ITEM FITS
        DO 202 J=1,NN
          XX(J) = 0
          XLL(J) = 0
  202   CONTINUE
        XX(JMAXP) = 1
        XLL(JMAXP) = 1
        LUBBIG = MAXP
        ZBIG = MAXP
        NN = - NN
        LAMBDAU = 0
        LAMBDAW = -1
        RETURN
      ENDIF
      IF ( SUMW .LE. CH ) GO TO 300
C THE INSTANCE IS NOT TRIVIAL
      IF ( FLSORTPW .EQ. 1 ) GO TO 235
      IF ( SUMU .LE. DH ) GO TO 205
      IF ( LAMUC .GT. 0 ) RETURN
  205 DO 220 J=1,NN
        IF ( WW(J) .EQ. 0 ) GO TO 210
        RAT(COMPACTOUT(J)) = DBLE(PP(J))/WW(J)
        GO TO 220
  210   RAT(COMPACTOUT(J)) = INF + PP(J)
  220 CONTINUE
      CALL SORTRMDD(NN,RAT,COMPACTOUT,JDIM,WORIG)
      DO 230 J=1,NN
        K = COMPACTOUT(J)
        PP(J) = PORIG(K)
        WW(J) = WORIG(K)
        UU(J) = UORIG(K)
  230 CONTINUE
  235 IF ( SUMU .GT. DH ) RETURN
C
C SPECIAL CASES: ONE CONSTRAINT IS REDUNDANT
C
C 1) THE UU CONSTRAINT IS REDUNDANT
C    COMPUTE UPPER BOUND AND GREEDY SOLUTION
C    WITH THE PP/WW SORTING
      IF ( CONS1OPT .EQ. 1 ) THEN
        ZCORBIG = ZCOR*ISCALE
        CALL MT1MOD(NN,PP,WW,CH,ZCORBIG,XX,ZBIG,
     1              JDIM,DUMMY1,DUMMY2,DUMMY3,XLL,UU)
        IF ( ZBIG .EQ. ZCORBIG ) GO TO 250
        DO 240 J=1,NN
          XLL(J) = XX(J)
  240   CONTINUE
  250   LUBBIG = ZBIG
        LAMBDAW = 0
      ELSE
        CALL ONECONS(NN,PP,WW,CH,JDIM,LUBBIG,ZBIG,XX,XLL,LAMBDAW)
      ENDIF
      LAMBDAU = 0
      NN = - NN
      RETURN
  300 CONTINUE
C 2) THE WW CONSTRAINT IS REDUNDANT
C    COMPUTE UPPER BOUND AND GREEDY SOLUTION
C    WITH THE PP/UU SORTING
      DO 320 J=1,NN
        IF ( UU(J) .EQ. 0 ) GO TO 310
        RAT(COMPACTOUT(J)) = DBLE(PP(J))/UU(J)
        GO TO 320
  310   RAT(COMPACTOUT(J)) = INF + PP(J)
  320 CONTINUE
      CALL SORTRMDD(NN,RAT,COMPACTOUT,JDIM,UORIG)
      DO 330 J=1,NN
        K = COMPACTOUT(J)
        PP(J) = PORIG(K)
        UU(J) = UORIG(K)
        WW(J) = WORIG(K)
  330 CONTINUE
      IF ( CONS1OPT .EQ. 1 ) THEN
        ZCORBIG = ZCOR*ISCALE
        CALL MT1MOD(NN,PP,UU,DH,ZCORBIG,XX,ZBIG,
     1              JDIM,DUMMY1,DUMMY2,DUMMY3,XLL,WW)
        IF ( ZBIG .EQ. ZCORBIG ) GO TO 350
        DO 340 J=1,NN
          XLL(J) = XX(J)
  340   CONTINUE
  350   LUBBIG = ZBIG
        LAMBDAU = 0
      ELSE
        CALL ONECONS(NN,PP,UU,DH,JDIM,LUBBIG,ZBIG,XX,XLL,LAMBDAU)
      ENDIF
      LAMBDAW = 0
      NN = - NN
      RETURN
      END
      SUBROUTINE MT1MOD(NS,PS,WS,QSINPUT,KUB,XS,VS,
     1                   JDIM,D,MIN,PBAR,WBAR,ZBAR)
C
C SUBROUTINE TO SOLVE THE 0-1 SINGLE KNAPSACK PROBLEM
C
C MAXIMIZE    VS = PS(1)*XS(1) + ... + PS(NS)*XS(NS)
C SUBJECT TO:      WS(1)*XS(1) + ... + WS(NS)*XS(NS) .LE. QS ,
C                  XS(J) = 0 OR 1  FOR J=1,...,NS,
C                  VS .GT. KUB .
C
C THIS SUBROUTINE IS A MODIFIED VERSION OF SUBROUTINE MT1.
C
      INTEGER PS(JDIM),WS(JDIM),XS(JDIM),QS,VS
      INTEGER D(JDIM),MIN(JDIM),PBAR(JDIM),WBAR(JDIM),ZBAR(JDIM)
      INTEGER DIFF,PR,R,T,QSINPUT
      DOUBLE PRECISION A, B, C
      QS = QSINPUT
      VS = KUB
      IP = 0
      MS = QS
      DO 10 L=1,NS
        LL = L
        IF ( WS(L) .GT. MS ) GO TO 20
        IP = IP + PS(L)
        MS = MS - WS(L)
   10 CONTINUE
   20 LL = LL - 1
      IF ( MS .EQ. 0 ) GO TO 50
      PS(NS+1) = 0
      WS(NS+1) = QS + 1
      LIM = IP + DBLE(MS)*PS(LL+2)/WS(LL+2)
      A = IP + PS(LL+1)
      B = DBLE(WS(LL+1) - MS)*PS(LL)
      C = WS(LL)
      LIM1 = A - B/C
      IF ( LIM1 .GT. LIM ) LIM = LIM1
      IF ( LIM .LE. VS ) RETURN
      MINK = QS + 1
      MIN(NS) = MINK
      DO 30 J=2,NS
        KK = NS + 2 - J
        IF ( WS(KK) .LT. MINK ) MINK = WS(KK)
        MIN(KK-1) = MINK
   30 CONTINUE
      DO 40 J=1,NS
        D(J) = 0
   40 CONTINUE
      PR = 0
      LOLD = NS
      II = 1
      GO TO 170
   50 IF ( VS .GE. IP ) RETURN
      VS = IP
      DO 60 J=1,LL
        XS(J) = 1
   60 CONTINUE
      NN = LL + 1
      DO 70 J=NN,NS
        XS(J) = 0
   70 CONTINUE
      QS = 0
      RETURN
   80 IF ( WS(II) .LE. QS ) GO TO 90
      II1 = II + 1
      IF ( VS .GE. DBLE(QS)*PS(II1)/WS(II1) + PR ) GO TO 280
      II = II1
      GO TO 80
   90 IP = PBAR(II)
      MS = QS - WBAR(II)
      IN = ZBAR(II)
      LL = NS
      IF ( IN .GT. NS ) GO TO 110
      DO 100 L=IN,NS
        LL = L
        IF ( WS(L) .GT. MS ) GO TO 160
        IP = IP + PS(L)
        MS = MS - WS(L)
  100 CONTINUE
  110 IF ( VS .GE. IP + PR ) GO TO 280
      VS = IP + PR
      MFIRST = MS
      NN = II - 1
      DO 120 J=1,NN
        XS(J) = D(J)
  120 CONTINUE
      DO 130 J=II,LL
        XS(J) = 1
  130 CONTINUE
      IF ( LL .EQ. NS ) GO TO 150
      NN = LL + 1
      DO 140 J=NN,NS
        XS(J) = 0
  140 CONTINUE
  150 IF ( VS .NE. LIM ) GO TO 280
      QS = MFIRST
      RETURN
  160 L = LL
      LL = LL - 1
      IF ( MS .EQ. 0 ) GO TO 110
      IF ( VS .GE. PR + IP + DBLE(MS)*PS(L)/WS(L) ) GO TO 280
  170 WBAR(II) = QS - MS
      PBAR(II) = IP
      ZBAR(II) = LL + 1
      D(II) = 1
      NN = LL - 1
      IF ( NN .LT. II ) GO TO 190
      DO 180 J=II,NN
        WBAR(J+1) = WBAR(J) - WS(J)
        PBAR(J+1) = PBAR(J) - PS(J)
        ZBAR(J+1) = LL + 1
        D(J+1) = 1
  180 CONTINUE
  190 J1 = LL + 1
      DO 200 J=J1,LOLD
        WBAR(J) = 0
        PBAR(J) = 0
        ZBAR(J) = J
  200 CONTINUE
      LOLD = LL
      QS = MS
      PR = PR + IP
      IF ( LL - (NS - 2) ) 240, 220, 210
  210 II = NS
      GO TO 250
  220 IF ( QS .LT. WS(NS) ) GO TO 230
      QS = QS - WS(NS)
      PR = PR + PS(NS)
      D(NS) = 1
  230 II = NS - 1
      GO TO 250
  240 II = LL + 2
      IF ( QS .GE. MIN(II-1) ) GO TO 80
  250 IF ( VS .GE. PR ) GO TO 270
      VS = PR
      DO 260 J=1,NS
        XS(J) = D(J)
  260 CONTINUE
      MFIRST = QS
      IF ( VS .EQ. LIM ) RETURN
  270 IF ( D(NS) .EQ. 0 ) GO TO 280
      D(NS) = 0
      QS = QS + WS(NS)
      PR = PR - PS(NS)
  280 NN = II - 1
      IF ( NN .EQ. 0 ) GO TO 300
      DO 290 J=1,NN
        KK = II - J
        IF ( D(KK) .EQ. 1 ) GO TO 310
  290 CONTINUE
  300 QS = MFIRST
      RETURN
  310 R = QS
      QS = QS + WS(KK)
      PR = PR - PS(KK)
      D(KK) = 0
      IF ( R .LT. MIN(KK) ) GO TO 320
      II = KK + 1
      GO TO 80
  320 NN = KK + 1
      II = KK
  330 IF ( VS .GE. PR + DBLE(QS)*PS(NN)/WS(NN) ) GO TO 280
      DIFF = WS(NN) - WS(KK)
      IF ( DIFF ) 390, 340, 350
  340 NN = NN + 1
      GO TO 330
  350 IF ( DIFF .GT. R ) GO TO 340
      IF ( VS .GE. PR + PS(NN) ) GO TO 340
      VS = PR + PS(NN)
      DO 360 J=1,KK
        XS(J) = D(J)
  360 CONTINUE
      JJ = KK + 1
      DO 370 J=JJ,NS
        XS(J) = 0
  370 CONTINUE
      XS(NN) = 1
      MFIRST = QS - WS(NN)
      IF ( VS .NE. LIM ) GO TO 380
      QS = MFIRST
      RETURN
  380 R = R - DIFF
      KK = NN
      NN = NN + 1
      GO TO 330
  390 T = R - DIFF
      IF ( T .LT. MIN(NN) ) GO TO 340
      N = NN + 1
      IF ( VS .GE. PR + PS(NN) + DBLE(T)*PS(N)/WS(N) ) GO TO 280
      QS = QS - WS(NN)
      PR = PR + PS(NN)
      D(NN) = 1
      II = NN + 1
      WBAR(NN) = WS(NN)
      PBAR(NN) = PS(NN)
      ZBAR(NN) = II
      N1 = NN + 1
      DO 400 J=N1,LOLD
        WBAR(J) = 0
        PBAR(J) = 0
        ZBAR(J) = J
  400 CONTINUE
      LOLD = NN
      GO TO 80
      END
      SUBROUTINE ONECONS(NN,PP,WW,CH,JDIM,
     1                   LUBBIG,ZBIG,XX,XLL,LAMBDA)
C COMPUTE UPPER BOUND AND GREEDY SOLUTION
C WHEN ONLY ONE CONSTRAINT IS ACTIVE
      IMPLICIT NONE
      INTEGER JDIM, NN, LUBBIG
      INTEGER PP(JDIM),WW(JDIM),XLL(JDIM),XX(JDIM)
      INTEGER ZBIG
      INTEGER CH
      INTEGER I,J,K,LL,LLP1,LIM,A,B,LIM1
      INTEGER SUMW,SUMU,IP,CHS
      INTEGER LAMBDA
      IP = 0
      CHS = CH
      DO 5 LL=1,NN
        IF ( WW(LL) .GT. CHS ) GO TO 10
        IP = IP + PP(LL)
        CHS = CHS - WW(LL)
        XLL(LL) = 1
        XX(LL) = 1
    5 CONTINUE
      STOP 999
   10 XLL(LL) = -1
      XX(LL) = 0
      LLP1 = LL + 1
      ZBIG = IP
      DO 15 J=LLP1,NN
        XLL(J) = 0
        XX(J) = 0
        IF ( WW(J) .GT. CHS ) GO TO 15
        XX(J) = 1
        ZBIG = ZBIG + PP(J)
        CHS = CHS - WW(J)
   15 CONTINUE
      LL = LL - 1
      PP(NN+1) = 0
      WW(NN+1) = CH
   65 LIM = IP + CHS*DBLE(PP(LL+2))/WW(LL+2)
      A = WW(LL+1) - CHS
      B = IP + PP(LL+1)
      LIM1 = B - A*DBLE(PP(LL))/WW(LL)
      IF ( LIM1 .GT. LIM ) LIM = LIM1
      IF ( LIM .LT. LUBBIG ) LUBBIG = LIM
      LAMBDA = PP(LL+1)/WW(LL+1)
      RETURN
      END
      SUBROUTINE POSTPROC7(NN,LUBBIG,ZBIG,XX,XLL,XLLC,COMPACTIN,
     1        COMPACTOUT,ISCALE,JDIM,NCOR,LUB,ZCOR,N,X,XFIX,XLAGR,XC,
     2        JSTART)
C
C POSTPROCESSING
C
C REINSERT USELESS ITEMS AND UPDATE ZCOR AND LUB
C COMPACTOUT(J) = POSITION OF THE J-TH USEFUL ITEM
C                   IN THE ORIGINAL VECTORS (J=1,...,NN)
      IMPLICIT NONE
      INTEGER JDIM, NCOR, LUBBIG
      INTEGER XC(JDIM),XLLC(JDIM),XLL(JDIM)
      INTEGER XX(JDIM),COMPACTIN(JDIM),COMPACTOUT(JDIM),NN,JSTART
      INTEGER X(JDIM),XLAGR(JDIM)
      INTEGER N,XFIX(JDIM)
      INTEGER ZBIG,ZCOR,LUB,ISCALE
      INTEGER I,J,K,LL
      DO 10 J=1,NCOR
        XC(J) = 0
        XLAGR(J) = 0
   10 CONTINUE
      DO 20 I=1,NN
        J = COMPACTOUT(I) - JSTART + 1
        XC(J) = XLLC(I)
        XLAGR(J) = XLL(I)
   20 CONTINUE
      IF (LUB .EQ. 0) LUB = LUBBIG/ISCALE
      IF (LUBBIG/ISCALE .LT. LUB ) LUB = LUBBIG/ISCALE
      IF (ZBIG/ISCALE .LE. ZCOR ) RETURN
      DO 25 I=1,N
        X(I) = XFIX(I)
   25 CONTINUE
      DO 30 I=1,NCOR
        J = COMPACTIN(I)
        X(J) = 0
   30 CONTINUE
      DO 40 I=1,NN
        J = COMPACTOUT(I) - JSTART + 1
        X(J) = XX(I)
   40 CONTINUE
      ZCOR = ZBIG/ISCALE
      RETURN
      END
      SUBROUTINE INRED2(NN,P,ISCALE,WR,UR,ICW,ICU,W,C,RAT,
     1                  COMPACTIN,IND,ZZ,NNF,XFIX,IZ1,NP1,COMPACTOUT,
     2                  PCOR,WCOR,UCOR)
C
C REDUCE THE INPUT PROBLEM (NN,P,WR,UR,ICW,ICU, POINTING TO THE ORIGINAL
C INSTANCE THROUGH COMPACTIN(IND(J)), WITH SURROGATE WEIGHTS
C W, CAPACITY C, RATIO RAT) WITH ITEMS SORTED
C ACCORDING TO DECREASING VALUES OF DOUBLE PRECISION ARRAY
C RAT (= PROFIT PER UNIT SURROGATE WEIGHT)
C
C CONSEQUENTLY RE-DEFINE PROBLEM (NN,PCOR,WCOR,UCOR), WHICH IS THE SAME
C PROBLEM SORTED BY DECREASING PCOR(J)/WCOR(J) VALUES, AND SCALE
C THE PROFITS
C
C IND(INPUT) = POINTERS FROM THE INPUT PROBLEM TO THE NON SORTED PROBLEM
C COMPACTOUT = POINTERS FROM THE REDUCED PCOR, WCOR, UCOR PROBLEM TO
C THE ORIGINAL PROBLEM
C ZZ(INPUT) = FEASIBLE SOLUTION VALUE FOR THE INPUT PROBLEM
C THE REDUCED PROBLEM IS (NNF,P,WR,UR,ICW,ICU)
C VARIABLES FIXED TO 1 AND TO 0 ARE STORED IN XFIX, IN THE POSITIONS
C CORRESPONDING TO THE NON SORTED PROBLEM.
C IZ1        = TOTAL PROFIT OF THE ITEMS FIXED TO 1
C INTERNAL VARIABLES
C IVUB(J)    = UPPER BOUND IF ITEM J OF THE REDUCED PROBLEM IS SET TO 0
C              (J=1, ..., JCRIT-1)
C            = UPPER BOUND IF ITEM J OF THE REDUCED PROBLEM IS SET TO 1
C              (J=JCRIT, ..., NNF)
      IMPLICIT NONE
      INTEGER ICW,ICU,CWR,ICWR,ICUR,SWR,SUR,MAXWR,MAXUR,IZ1OLD
      INTEGER NP1, IZ1, NNF, IP, C, J, JCRIT, LL, IUB, IUB1, I, AR,
     1        AP, K, ICRUB, NN, JR, II, ZZ, NNFJCR, IIJCR, IR
      INTEGER WR(NP1),UR(NP1),COMPACTIN(NP1),COMPACTOUT(NP1)
      INTEGER P(NP1),W(NP1),XFIX(NP1),IND(NP1)
      INTEGER PCOR(NP1),WCOR(NP1),UCOR(NP1),ISCALE
      DOUBLE PRECISION RAT(NP1)
      INTEGER IVUB(10002)
C INITIALIZE
      IZ1OLD = IZ1
      NNF = 0
C DETERMINE THE CRITICAL ITEM JCRIT OF THE SURROGATE PROBLEM
      IP = 0
      CWR = C
      J = 1
   10 IF ( CWR .LT. W(J) ) GO TO 20
      CWR = CWR - W(J)
      IP = IP + P(J)
      J = J + 1
      GO TO 10
   20 JCRIT = J
C COMPUTE THE MARTELLO-TOTH (1977) UPPER BOUND IUB FOR THE SURROGATE PROBLEM
      LL = JCRIT - 1
      P(NP1) = 0
      W(NP1) = C + 1
      RAT(NP1) = 0
      IUB = IP + CWR*RAT(LL+2)
      IUB1 = IP + P(LL+1) - (W(LL+1) - CWR)*RAT(LL)
      IF ( IUB1 .GT. IUB ) IUB = IUB1
C COMPUTE UPPER BOUND IVUB(I) (WITH ITEM I IMPOSED TO 0) FOR I .LE. JCRIT
      DO 150 I=1,JCRIT
        AR = CWR + W(I)
        AP = IP - P(I)
        K = JCRIT
  130   IF ( AR .LT. W(K) ) GO TO 140
        AR = AR - W(K)
        AP = AP + P(K)
        K = K + 1
        GO TO 130
  140   IVUB(I) = AP + AR*RAT(K)
  150 CONTINUE
C ICRUB = UPPER BOUND (WITH ITEM I IMPOSED TO 0) FOR I = JCRIT
      ICRUB = IVUB(JCRIT)
C COMPUTE UPPER BOUND IVUB(I) (WITH ITEM I IMPOSED TO 1) FOR I .GE. JCRIT
      DO 180 I=JCRIT,NN
        AR = CWR - W(I)
        AP = IP + P(I)
        K = JCRIT
  160   IF ( AR .GE. 0 ) GO TO 170
        K = K - 1
        AR = AR + W(K)
        AP = AP - P(K)
        GO TO 160
  170   IVUB(I) = AP + AR*RAT(K)
  180 CONTINUE
C
C DEFINE THE REDUCED PROBLEM
C
      JR = JCRIT - 1
C TRY TO FIX TO 1 ITEMS PRECEDING THE CRITICAL ITEM
      DO 200 I=1,JR
        II = IND(I)
        IF ( IVUB(I) .LE. ZZ ) GO TO 190
        XFIX(COMPACTIN(II)) = 2
        NNF = NNF + 1
        P(NNF) = P(I)
        WR(NNF) = WR(I)
        UR(NNF) = UR(I)
        PCOR(II) = P(NNF)
        WCOR(II) = WR(NNF)
        UCOR(II) = UR(NNF)
        GO TO 200
  190   XFIX(COMPACTIN(II)) = 1
        ICW  = ICW  - WR(I)
        ICU  = ICU  - UR(I)
        IZ1 = IZ1 + P(I)
        PCOR(II) = -1
  200 CONTINUE
C STORE THE NUMBER OF FREE ITEMS PRECEDING THE CRITICAL ITEM
C AND THE CRITICAL ITEM POSITION
      NNFJCR = NNF
      IIJCR = IND(JCRIT)
      IF ( ICW .LT. 0 .OR. ICU .LT. 0 ) GO TO 330
C TRY TO FIX TO 1 THE CRITICAL ITEM
      IR = JCRIT
      IF ( ICRUB .GT. ZZ ) GO TO 210
      XFIX(COMPACTIN(IIJCR)) = 1
      ICW = ICW  - WR(JCRIT)
      ICU = ICU  - UR(JCRIT)
      IF ( ICW  .LT. 0 .OR. ICU  .LT. 0 ) GO TO 330
      IZ1 = IZ1 + P(JCRIT)
      PCOR(IIJCR) = -1
C CHECK WHETHER THE CRITICAL ITEM MUST ALSO BE SET TO 0
      IF ( IVUB(JCRIT) .LE. ZZ ) GO TO 330
      IR = JCRIT + 1
      IF ( IR .GT. NN ) GO TO 240
C TRY TO FIX TO 0 ITEMS FOLLOWING THE CRITICAL ITEM (INCLUDED)
  210 DO 230 I=IR,NN
        II = IND(I)
        IF ( IVUB(I) .LE. ZZ ) GO TO 220
        XFIX(COMPACTIN(II)) = 2
        NNF = NNF + 1
        P(NNF) = P(I)
        WR(NNF) = WR(I)
        UR(NNF) = UR(I)
        PCOR(II) = P(NNF)
        WCOR(II) = WR(NNF)
        UCOR(II) = UR(NNF)
        GO TO 230
  220   XFIX(COMPACTIN(II)) = 0
        PCOR(II) = -1
  230 CONTINUE
  240 NNF = 0
      DO 250 I=1,NN
        IF ( PCOR(I) .LT. 0 ) GO TO 250
        NNF = NNF + 1
        PCOR(NNF) = PCOR(I)*ISCALE
        WCOR(NNF) = WCOR(I)
        UCOR(NNF) = UCOR(I)
        COMPACTOUT(NNF) = COMPACTIN(I)
  250 CONTINUE
      RETURN
C THE CURRENT SOLUTION OF VALUE ZZ IS OPTIMAL
  330 NNF = 0
      IZ1 = -1
      RETURN
      END
      SUBROUTINE BANDB22(N,P,ISCALE,W,U,CW,CU,LUB,XLAGR,LAMBDAU,XC,
     1                  LAMUC,LAMWC,WURED,Z,X,JDIM,MAXIT,NNODE,FLAGLOC,
     2                  XLL,XLLC,MINW,MINU,LUBLEV,LAMBDAULEV,BRANCHLEV,
     3                  PP,WW,DRDUMMY,UU,DUMMY4,COMPACTOUT,
     4                  MAXL,LEVL,LEVK)
C SOLVE THROUGH BRANCH-AND-BOUND THE CURRENT REDUCED INSTANCE,
C WHICH IS SORTED BY PROFIT PER UNIT SURROGATE VALUE.
C AVOIDS EXECUTION OF PREPROC IN THE BOUND COMPUTATION, IF NOTHING CAN CHANGE
C
C MEANING OF THE INPUT PARAMETERS:
C N     = NUMBER OF ITEMS  ( N <= 10000 WITH THE CURRENT DIMENSIONS);
C P(J)  = PROFIT OF ITEM  J  (J=1,...,N) MULTIPLIED BY ISCALE;
C ISCALE (SEE P(J));
C W(J)  = WEIGHT OF ITEM  J  (J=1,...,N);
C U(J)  = VOLUME OF ITEM  J  (J=1,...,N);
C CW    = WEIGHT CAPACITY OF THE KNAPSACK;
C CU    = VOLUME CAPACITY OF THE KNAPSACK;
C LUB   = LAGRANGIAN UPPER BOUND;
C XLAGR = VECTOR CORRESPONDING TO LUB;
C LAMBDAU = MULTIPLIER CORRESPONDING TO LUB;
C XC    = VECTOR CORRESPONDING TO THE CONTINUOUS RELAXATION;
C LAMUC = MULTIPLIER FOR THE U CONSTRAINT IN THE CONTINUOUS RELAXATION;
C LAMWC = MULTIPLIER FOR THE W CONSTRAINT IN THE CONTINUOUS RELAXATION;
C Z     = VALUE OF THE BEST SOLUTION SO FAR;
C X     = SOLUTION VECTOR CORRESPONDING TO Z;
C JDIM  = DIMENSION OF THE FORMAL PARAMETER ARRAYS;
C MAXIT = MAXIMUM NUMBER OF ITERATIONS TO BE PERFORMED;
C (XLL AND XLLC ARE DUMMY, USED AT EACH UPPER BOUND COMPUTATION TO STORE
C  THE LOCAL VALUES HAVING THE SAME NAMES)
C
C MEANING OF THE OUTPUT PARAMETERS:
C Z    = VALUE OF THE OPTIMAL SOLUTION;
C X    = SOLUTION VECTOR CORRSPONDING TO Z;
C      = 0 OTHERWISE.
C
C ARRAYS XLL,XLLC,MINW,MINU,LUBLEV,LAMBDAULEV,BRANCHLEV,PP,WW,UU,
C DRDUMMY,DUMMY4 AND COMPACTOUT ARE DUMMY VARIABLES USED FOR THE LOCAL VALUES
C
C ALL THE PARAMETERS (BUT DRDUMMY) ARE INTEGER.
C
C LOCAL VARIABLES:
C MINW(J)       = MINIMUM WEIGHT OF AN ITEM FOLLOWING J
C MINU(J)       = MINIMUM VOLUME OF AN ITEM FOLLOWING J
C MAXW(J)       = MAXIMUM WEIGHT OF AN ITEM FOLLOWING J
C MAXU(J)       = MAXIMUM VOLUME OF AN ITEM FOLLOWING J
C SUMW(J)       = TOTAL WEIGHT OF THE ITEMS FOLLOWING J
C SUMU(J)       = TOTAL VOLUME OF THE ITEMS FOLLOWING J
C LUBLEV(L)     = LAGRANGIAN UPPER BOUND AT LEVEL L (AFTER FIXING XX(L-1))
C LAMBDAULEV(L) = LAMBDAU VALUE AT LEVEL L
C BRANCHLEV(L)  = 1 IF AT LEVEL L THE BRANCHING IS 1 FIRST, 0 SECOND
C               = 0 IF AT LEVEL L THE BRANCHING IS 0 FIRST, 1 SECOND (IF L FITS)
C               < 0 IF AT THE LAST LAGRANGIAN BOUND COMPUTATION L WAS
C                 THE CRITICAL ITEM, SO THE BRANCHING IS 1 FIRST, 0 SECOND
C                 IF L FITS, ONLY 0 OTHERWISE
C IPLEV(L)  = PROFIT SUM OF ITEMS PRECEDING THE CRITICAL ITEM IN THE
C             SIMPLEUB COMPUTATION PERFORMED AT LEVEL L
C LLEV(L)   = LAST ITEM FITTING (STARTING FROM L)
C             IN THE SIMPLEUB COMPUTATION PERFORMED AT LEVEL L
C LP1LEV(L) = NEXT FEASIBLE ITEM (STARTING FROM L)
C             IN THE SIMPLEUB COMPUTATION PERFORMED AT LEVEL L
C CHSLEV(L) = RESIDUAL SURROGATE CAPACITY IN THE
C             SIMPLEUB COMPUTATION PERFORMED AT LEVEL L
C LEVLEV(L) = CLOSEST ANCESTOR OF L (LEVLEV(L) .LE. L)
C             AT WHICH SIMPLEUB WAS COMPUTED (AFTER FIXING XX(L-1))
C CWLEV(L)  = RESIDUAL CW CAPACITY AT LEVEL L (I.E., AFTER FIXING XX(L-1))
C CULEV(L)  = RESIDUAL CU CAPACITY AT LEVEL L (I.E., AFTER FIXING XX(L-1))
C
      IMPLICIT NONE
      INTEGER JDIM,ISCALE,MAXIT,NNODE
      INTEGER N,P(JDIM),W(JDIM),U(JDIM),CW,CU,X(JDIM),Z
      INTEGER LUB,XLAGR(JDIM),LAMBDAU,XC(JDIM),LAMUC,LAMWC
      INTEGER XLL(JDIM),XLLC(JDIM)
      INTEGER MINW(JDIM),MINU(JDIM),LUBLEV(JDIM),LAMBDAULEV(JDIM),
     1        BRANCHLEV(JDIM),PP(JDIM),WW(JDIM)
C      INTEGER DUMMY3(JDIM),DUMMY4(JDIM),DUMMY5(JDIM)
      INTEGER UU(JDIM),DUMMY4(JDIM),COMPACTOUT(JDIM)
      DOUBLE PRECISION DRDUMMY(JDIM)
      INTEGER XX(10002),COMPACTIN(10002),XCOR(10002),XFIX(10002)
C
      INTEGER LIM,MINCW,MINCU,J,KK,ICW,ICU,L,ZCOR,PROFIT,II,
     1        ZCORINPUT,LUBCOR,COMPUTE,FLSORTPW,CONS1OPT,LAMBDAUNEW,
     2        NITER,NN,LUBTRUE,ZDUMMY
      INTEGER KPLUB
      INTEGER ZFLAG,ZOLD
      INTEGER FLAGLOC
      INTEGER SUMW(10002), SUMU(10002), MAXW(10002), MAXU(10002),
     1        MAXCW, MAXCU, FLAGPREP, LEVPREP, DLEVPREP, JSTART,
     2        JSTARTM, NNN
      INTEGER MAXL,LEVL,LEVK
      INTEGER NCOMP0
      INTEGER LUBKP
      INTEGER WURED(JDIM),LAMUCORIG,LAMWCORIG,CWU
      INTEGER IPLEV(10002), CHSLEV(10002), LLLEV(10002),
     1        LLP1LEV(10002), CHSLV, LUBWEAK, IPLV, LLLV, LLP1LV
      INTEGER LEVLEV(10002), CWLEV(10002), CULEV(10002), LEVEL
      INTEGER CWS, CUS, LS
      REAL TIMELIMIT, T1, T2
      COMMON /XXTIME/ TIMELIMIT, T1
      COMMON /COMP/ NCOMP0
      NCOMP0 = 0
C
C INITIALIZATION
C
      LAMUCORIG = LAMUC
      LAMWCORIG = LAMWC
      LIM = LUB
      DO 10 J=1,N
        XX(J) = 0
        COMPACTIN(J) = J
        XFIX(J) = 2
   10 CONTINUE
C COMPUTE MINW, MINU, MAXW, MAXU, SUMW, SUMU
      MINCW = CW + 1
      MINW(N) = MINCW
      MINCU = CU + 1
      MINU(N) = MINCU
      MAXCW = -1
      MAXW(N) = MAXCW
      MAXCU = -1
      MAXU(N) = MAXCU
      SUMW(N) = 0
      SUMU(N) = 0
      DO 30 J=2,N
        KK = N + 2 - J
        IF ( W(KK) .LT. MINCW ) MINCW = W(KK)
        MINW(KK-1) = MINCW
        IF ( U(KK) .LT. MINCU ) MINCU = U(KK)
        MINU(KK-1) = MINCU
        IF ( W(KK) .GT. MAXCW ) MAXCW = W(KK)
        MAXW(KK-1) = MAXCW
        IF ( U(KK) .GT. MAXCU ) MAXCU = U(KK)
        MAXU(KK-1) = MAXCU
        SUMW(KK-1) = SUMW(KK) + W(KK)
        SUMU(KK-1) = SUMU(KK) + U(KK)
   30 CONTINUE
      ICW = CW
      ICU = CU
      PROFIT = 0
      II = 1
      LUBLEV(1) = LUB
      LAMBDAULEV(1) = LAMBDAU
      BRANCHLEV(1) = XLAGR(1)
      LEVPREP = 1
      FLAGPREP = 1
      DLEVPREP = 0
C INITIALIZE THE PARAMETERS FOR THE SUBSEQUENT SIMPLEUB CALLS
      IPLEV(1) = 0
      CHSLEV(1) = LAMWCORIG*CW + LAMUCORIG*CU
      LLLEV(1) = 0
      LLP1LEV(1) = 1
      P(N+1) = 0
      WURED(N+1) = CHSLEV(1) + 1
      CALL SIMPLEUB1(N,P,WURED,
     1               CHSLEV(1),IPLEV(1),LLLEV(1),LLP1LEV(1),
     2               W,U,CW,CU,JDIM,LUBWEAK)
      LEVLEV(1) = 1
      CWLEV(1) = CW
      CULEV(1) = CU
C
C FORWARD STEP
C
  120 IF ( BRANCHLEV(II) .EQ. 0 ) GO TO 130
      IF ( W(II) .GT. CW .OR. U(II) .GT. CU ) GO TO 130
  125 XX(II) = 1
      CW = CW - W(II)
      CU = CU - U(II)
      PROFIT = PROFIT + P(II)/ISCALE
      IF ( CW .LT. MINW(II) .OR. CU .LT. MINU(II) ) GO TO 390
      GO TO 150
  130 XX(II) = 0
      IF ( W(II) .GT. CW .OR. U(II) .GT. CU ) DLEVPREP = DLEVPREP + 1
      IF ( II .EQ. N ) GO TO 390
C
C LAGRANGIAN UPPER BOUND
C
  150 COMPUTE = 0
      IF ( XX(II) .NE. BRANCHLEV(II) ) COMPUTE = 1
C*************************************
C POSSIBILE MIGLIORAMENTO. DECIDERE SUL VALORE DI COMPUTE ALL'INTERNO
C DOPO IL PREPROCESSING E CALCOLARE IL BOUND SE L'ITEM CRITICO
C ATTUALE E' STATO ELIMINATO DAL PREPROCESSING.
C*************************************
      ZCOR = Z - PROFIT
      ZCORINPUT = ZCOR
      LUBCOR = LUBLEV(II) - PROFIT
      FLSORTPW = 0
      CONS1OPT = 1
      LAMUC = LAMBDAULEV(II)
      LAMBDAUNEW = LAMUC
C
C THE CURRENT PROBLEM CORRESPONDS TO LOCATIONS FROM II+1.
C
C INPUT: N-II,P(II+1),W(II+1),U(II+1),CW,CU,ZCOR,ISCALE,JDIM,FLSORTPW,CONS1OPT,
C        COMPACTIN(II+1),P(II+1),W(II+1),U(II+1),LUBCOR,LAMUC,COMPUTE
C   (THE SECOND COPY OF P,W,U SHOULD CORRESPOND TO THE ORIGINAL NON-COMPACT
C    INSTANCE, BUT BANDB IS APPLIED TO A COMPACT INSTANCE)
C
C OUTPUT: ZCOR,XCOR(II+1),LUBCOR,LAMBDAUNEW,XLAGR(II+1),LAMUC,LAMWC,
C         XC(II+1),COMPUTE,NITER
C
C LEVPREP = LAST LEVEL AT WHICH PREPROC WAS EXECUTED IN TWOKPUB
C DLEVPREP = NUMBER OF ELIMINATED ITEMS SINCE THE LAST PREPROC EXECUTION
C
C DUMMY: XLL,XLLC,ZDUMMY,DUMMY4
C
C XLAGR AND XC ARE MODIFIED ONLY IF THE BOUND IS COMPUTED (OR IF THE CURRENT
C INSTANCE IS COMPLETELY SOLVED (BUT IN THIS CASE, THEY ARE NOT USED)
C
C DECIDE ON EXECUTION OF PREPROC WITHIN TWOKPUB
      IF ( II .LE. LEVPREP ) THEN
         FLAGPREP = 1
      ELSE
         FLAGPREP = 0
         IF ( MAXW(II) .GT. CW .OR. MAXU(II) .GT. CU ) FLAGPREP = 1
         IF ( SUMW(II) .LE. CW .OR. SUMU(II) .LE. CU ) FLAGPREP = 1
         IF ( N - II .LE. 2 ) FLAGPREP = 1
      ENDIF
      IF ( FLAGPREP .EQ. 1 ) THEN
        JSTART = - 1
        JSTARTM = 1
        DLEVPREP = 0
      ELSE
        JSTART = II - LEVPREP + 1
        JSTARTM = II - (LEVPREP + DLEVPREP) + 1
      ENDIF
      NNN = NN - (II - (LEVPREP + DLEVPREP))
      IF ( LUBLEV(II) .LE. Z ) GO TO 420
      IF ( II .LT. 0 ) GO TO 180
      LEVEL = LEVLEV(II)
      IF ( ( XX(II) .EQ. 1 .AND.
     1       ( MAXW(II) .GT. CW .OR. MAXU(II) .GT. CU ) )
     2                      .OR.
     3     ( XX(II) .EQ. 0 .AND.
     4       ( W(II) .LE. CWLEV(LEVEL) .AND.
     5         U(II) .LE. CULEV(LEVEL) ) ) )
     6     THEN
             IF ( LLLEV(II) .GE. 1 ) THEN
               IF ( XX(II) .EQ. 0 ) THEN
                 CHSLV = CHSLEV(II) + WURED(II)
                 IPLV = IPLEV(II) - P(II)
                 LLLV = LLLEV(II) - 1
                 LLP1LV = LLP1LEV(II) -1
               ELSE
                 CHSLV = LAMWCORIG*CW + LAMUCORIG*CU
                 IPLV = 0
                 LLLV = 0
                 LLP1LV = 1
               ENDIF
             ELSE
               CHSLV = CHSLEV(II)
               IPLV = 0
               LLLV = 0
               LLP1LV = 1
             ENDIF
           LEVLEV(II+1) = II + 1
           CWLEV(II+1) = CW
           CULEV(II+1) = CU
           CALL SIMPLEUB1(N-II,P(II+1),WURED(II+1),
     1                    CHSLV,IPLV,LLLV,LLP1LV,
     2                    W(II+1),U(II+1),CW,CU,JDIM,LUBCOR)
           CHSLEV(II+1) = CHSLV
           IPLEV(II+1) = IPLV
           LLLEV(II+1) = LLLV
           LLP1LEV(II+1) = LLP1LV
           LUBCOR = LUBCOR/ISCALE
           NNODE = NNODE + 1
           IF ( NNODE/100*100 .EQ. NNODE ) THEN
             CALL SECOND(T2)
             IF ( T2 - T1 .GT. TIMELIMIT ) THEN
               WRITE (6, 199) T2 - T1
               WRITE (7, 199) T2 - T1
               WRITE (8, 199) T2 - T1
  199          FORMAT (30X,'@@@@@@@@@@ TIME LIMIT MTTWO27',F12.2)
               RETURN
             ENDIF
           ENDIF
           LUBTRUE = PROFIT + LUBCOR
      ELSE
           CHSLEV(II+1) = CHSLEV(II)
           IPLEV(II+1) = IPLEV(II) - P(II)*XX(II)
           LLLEV(II+1) = LLLEV(II) - 1
           LLP1LEV(II+1) = LLP1LEV(II) - 1
           LUBTRUE = LUBLEV(II)
           LEVLEV(II+1) = LEVLEV(II)
           CWLEV(II+1) = - 1
           CULEV(II+1) = - 1
      ENDIF
      LAMBDAUNEW = LAMUC
C THE EXACT KP SOLUTION MUST NOT BE DETERMINED
      COMPUTE = 0
C      IF ( LUBTRUE .LE. Z ) GO TO 420
C      GO TO 360
      GO TO 190
  180 CALL TWOKPUB12(N-II,P(II+1),W(II+1),U(II+1),CW,CU,MINW(II),
     1              MINU(II),FLAGPREP,ZCOR,XCOR(II+1),N-II,XFIX,
     1              ISCALE,JDIM,FLSORTPW,CONS1OPT,COMPACTIN,P(II+1),
     2              W(II+1),U(II+1),LUBCOR,LAMBDAUNEW,XLAGR(II+1),XLL,
     3              LAMUC,LAMWC,XC(II+1),XLLC,COMPUTE,NITER,
     4              NNN,PP(JSTARTM),WW(JSTARTM),UU(JSTARTM),ZDUMMY,
     1              DUMMY4,COMPACTOUT(JSTARTM),JSTART,MAXL,LEVL,II)
      NCOMP0 = NCOMP0 + 1 - COMPUTE
C      WRITE (6,8364) NITER
 8364 FORMAT('    ############### NITER =',I6)
      IF ( FLAGPREP .EQ. 1 ) THEN
         LEVPREP = II
         NN = NNN
      ENDIF
      NNODE = NNODE + COMPUTE
      IF ( NNODE/100*100 .EQ. NNODE ) THEN
        CALL SECOND(T2)
        IF ( T2 - T1 .GT. TIMELIMIT ) THEN
          WRITE (6, 199) T2 - T1
          WRITE (7, 199) T2 - T1
          WRITE (8, 199) T2 - T1
          RETURN
        ENDIF
      ENDIF
      LUBTRUE = PROFIT + LUBCOR
  190 IF ( ZCOR .LE. ZCORINPUT ) GO TO 250
C A NEW OPTIMAL SOLUTION HAS BEEN FOUND BY THE UPPER BOUND COMPUTATION
      Z = PROFIT + ZCOR
      DO 200 J=1,II
        X(J) = XX(J)
  200 CONTINUE
      DO 210 J=II+1,N
        X(J) = XCOR(J)
  210 CONTINUE
C      WRITE (9,6666) NNODE,Z
C      WRITE (9,6666) (X(J),J=1,N)
C      WRITE (6,6666) NNODE,Z
C      WRITE (6,6666) (X(J),J=1,N)
 6666 FORMAT(1X,10I7)
      IF ( Z .EQ. LIM ) GO TO 500
  220 ZFLAG = -1
      ZOLD = Z
      CALL LOCAL4(N,P,W,U,ICW,ICU,Z,X,X,ZFLAG,X,JDIM,ISCALE)
      IF ( Z .EQ. LIM ) GO TO 500
      IF ( Z .GT. ZOLD ) GO TO 220
  250 IF ( LUBTRUE .LE. Z ) GO TO 420
      LUBKP = LUBTRUE
C THE CURRENT PROBLEM HAS NOT BEEN SOLVED.
C IMPROVE THE BOUND THROUGH EXACT KP 0-1 SOLUTION
      IF ( COMPUTE .EQ. 0 ) GO TO 350
      IF ( II/LEVK*LEVK .NE. II ) GO TO 350
      ZCORINPUT = ZCOR
      CALL KPUB12(N-II,P(II+1),W(II+1),U(II+1),CW,CU,ZCOR,XCOR(II+1),
     1          ISCALE,JDIM,KPLUB,LAMBDAUNEW,XLAGR(II+1),0,FLAGLOC)
      IF ( KPLUB .GT. LUBCOR ) THEN
         WRITE (6,5) KPLUB,LUBCOR
         WRITE (7,5) KPLUB,LUBCOR
         WRITE (8,5) KPLUB,LUBCOR
      ENDIF
    5 FORMAT (' ************************* KPLUB, LUB',2I10)
      LUBCOR = KPLUB
C LUBKP IS NOT A TRUE UPPER BOUND IF IT IS GREATER THAN ZCOR
      LUBKP = PROFIT + LUBCOR
      IF ( ZCOR .LE. ZCORINPUT ) GO TO 350
C A NEW OPTIMAL SOLUTION HAS BEEN FOUND BY THE UPPER BOUND COMPUTATION
      Z = PROFIT + ZCOR
      DO 300 J=1,II
        X(J) = XX(J)
  300 CONTINUE
      DO 310 J=II+1,N
        X(J) = XCOR(J)
  310 CONTINUE
C      WRITE (9,6666) NNODE,Z
C      WRITE (9,6666) (X(J),J=1,N)
C      WRITE (6,6666) NNODE,Z
C      WRITE (6,6666) (X(J),J=1,N)
      IF ( Z .EQ. LIM ) GO TO 500
  320 ZFLAG = -1
      ZOLD = Z
      CALL LOCAL4(N,P,W,U,ICW,ICU,Z,X,X,ZFLAG,X,JDIM,ISCALE)
      IF ( Z .EQ. LIM ) GO TO 500
      IF ( Z .GT. ZOLD ) GO TO 320
  350 IF ( LUBKP .LE. Z ) GO TO 420
C STORE INFORMATION FOR THE NEXT FORWARD STEP
  360 II = II + 1
      LUBLEV(II) = LUBTRUE
      LAMBDAULEV(II) = LAMBDAUNEW
      BRANCHLEV(II) = XLAGR(II)
      GO TO 120
C
C SAVE THE CURRENT OPTIMAL SOLUTION
C
  390 IF ( Z .GE. PROFIT ) GO TO 410
      Z = PROFIT
      DO 400 J=1,N
        X(J) = XX(J)
  400 CONTINUE
C      WRITE (9,6666) NNODE,Z
C      WRITE (9,6666) (X(J),J=1,N)
C      WRITE (6,6666) NNODE,Z
C      WRITE (6,6666) (X(J),J=1,N)
      IF ( Z .EQ. LIM ) GO TO 500
  405 ZFLAG = -1
      ZOLD = Z
      CALL LOCAL4(N,P,W,U,ICW,ICU,Z,X,X,ZFLAG,X,JDIM,ISCALE)
      IF ( Z .EQ. LIM ) GO TO 500
      IF ( Z .GT. ZOLD ) GO TO 405
C********************************************
C ATTENZIONE: CAMBIATO
C********************************************
  410 CONTINUE
C  410 IF ( XX(N) .EQ. 0 ) GO TO 420
C      XX(N) = 0
C      CW = CW + W(N)
C      CU = CU + U(N)
C      PROFIT = PROFIT - P(N)/ISCALE
C
C BACKTRACK
C
  420 IF ( XX(II) .EQ. BRANCHLEV(II) ) GO TO 440
C THE SECOND SON WAS EXPLORED OR II IS THE CRITICAL ITEM
      IF ( XX(II) .EQ. 0 ) GO TO 430
C REMOVE THE CURRENT ITEM
      XX(II) = 0
      CW = CW + W(II)
      CU = CU + U(II)
      PROFIT = PROFIT - P(II)/ISCALE
      IF ( BRANCHLEV(II) .LT. 0 ) GO TO 150
C PERFORM ANOTHER BACKTRACKING
  430 II = II - 1
      IF ( II .GT. 0 ) GO TO 420
      GO TO 500
C THE FIRST SON WAS EXPLORED: GENERATE THE SECOND SON
  440 IF ( XX(II) .EQ. 0 ) GO TO 450
C REMOVE THE CURRENT ITEM
      XX(II) = 0
      CW = CW + W(II)
      CU = CU + U(II)
      PROFIT = PROFIT - P(II)/ISCALE
      GO TO 150
C INSERT THE CURRENT ITEM (IF IT FITS)
  450 IF ( W(II) .GT. CW .OR. U(II) .GT. CU ) THEN
        DLEVPREP = DLEVPREP - 1
        GO TO 430
      ELSE
        XX(II) = 1
        CW = CW - W(II)
        CU = CU - U(II)
        PROFIT = PROFIT + P(II)/ISCALE
        IF ( CW .LT. MINW(II) .OR. CU .LT. MINU(II) ) GO TO 390
        GO TO 150
      ENDIF
  500 RETURN
      END
      SUBROUTINE KPUB11(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,XCOR,ISCALE,
     1                    JDIM,LUB,LAMBDA,XLAGR,FLGLOC,FLAGLOC)
C COMPUTE THE LAGRANGIAN UPPER BOUND FOR THE TWO-DIMENSIONAL KP
C BY EXACTLY SOLVING THE 0-1 SINGLE KP FOR MULTIPLIER LAMBDA
C
C INPUT:
C   CURRENT PROBLEM: NCOR, PCOR/ISCALE, WCOR, UCOR
C                    CH, DH WITH BEST INCUMBENT SOLUTION VALUE ZCOR;
C                    THE TOTAL WEIGHT WCOR IS .GT. CH,
C                    NCOR IS AT LEAST 3,
C   LAMBDA = GIVEN MULTIPLIER
C   FLGLOC = 1 IF LOCAL AND LOCALPAIR MUST BE EXECUTED ON THE FEASIBLE
C            PART OF THE LAGRANGIAN SOLUTION
C
C OUTPUT:
C   LUB = LAGRANGIAN UPPER BOUND FOR THE EXACT SOLUTION
C   XLAGR  = SOLUTION VECTOR PRODUCING LUB
C   ZCOR = BEST SOLUTION VALUE FOUND (IF > ZCOR(INPUT)) FOR THE CURRENT PROBLEM
C   XCOR = SOLUTION VECTOR PRODUCING ZCOR
C
      IMPLICIT NONE
      INTEGER JDIM, NCOR, J, LUB, JJ, ISCALE, LAMBDA
      INTEGER PCOR(JDIM), WCOR(JDIM), UCOR(JDIM), XLAGR(JDIM)
      INTEGER XCOR(JDIM)
      DOUBLE PRECISION RAT(10002)
      INTEGER POINT(10002), ZCOR, CH, DH, PBAR(10002)
      INTEGER NMT, PMT(10002), WMT(10002), SUMW, SUMP, SUMU, ZMT
      INTEGER XMT(10002), XX(10002), MIN(10002), PSIGN(10002),
     1        WSIGN(10002), ZSIGN(10002), JCK
      REAL    WUCOR(10002)
      INTEGER PWITHW0
      INTEGER ZFLAG
      INTEGER FLGLOC, ZBEST, XBEST(10002), ZLOC, XLOC(1002)
      INTEGER SUMULOC, SUMWLOC, SUMPLOC
      INTEGER FLAGLOC
      DO 3 J=1,NCOR
        XLAGR(J) = 0
    3 CONTINUE
      PWITHW0 = 0
      NMT = 0
      SUMW = 0
      SUMP = 0
      SUMU = 0
      DO 10 J=1,NCOR
        PBAR(J) = PCOR(J) - LAMBDA*UCOR(J)
        IF ( PBAR(J) .LE. 0 ) GO TO 10
        IF ( WCOR(J) .GT. CH ) GO TO 10
        IF ( UCOR(J) .GT. DH ) GO TO 10
        IF ( WCOR(J) .GT. 0 ) GO TO 5
        PWITHW0 = PWITHW0 + PBAR(J)
        XLAGR(J) = 1
        GO TO 10
    5   NMT = NMT + 1
        POINT(NMT) = J
        RAT(J) = DBLE(PBAR(J))/DBLE(WCOR(J))
        SUMW = SUMW + WCOR(J)
        SUMP = SUMP + PBAR(J)
        SUMU = SUMU + UCOR(J)
        IF ( UCOR(J) .GT. 0 ) GO TO 7
        WUCOR(J) = CH
        GO TO 10
    7   WUCOR(J) = FLOAT(WCOR(J))/UCOR(J)
   10 CONTINUE
      IF ( SUMW .GT. CH .AND. NMT .GT. 2 ) GO TO 200
C SPECIAL CASES
      IF ( SUMW .GT. CH ) GO TO 100
C ALL ITEMS FIT
      LUB = (PWITHW0 + SUMP + DH*LAMBDA)/ISCALE
      DO 70 J=1,NMT
        XLAGR(POINT(J)) = 1
   70 CONTINUE
      GO TO 500
C NMT = 2
  100 IF ( PBAR(POINT(1)) .LT. PBAR(POINT(2)) ) GO TO 120
      LUB = (PWITHW0 + PBAR(POINT(1)) + DH*LAMBDA)/ISCALE
      XLAGR(POINT(1)) = 1
      GO TO 500
  120 LUB = (PWITHW0 + PBAR(POINT(2)) + DH*LAMBDA)/ISCALE
      XLAGR(POINT(2)) = 1
      GO TO 500
C EXACTLY SOLVE THE LAGRANGIAN PROBLEM
  200 CALL SORTRDRD(NMT,RAT,POINT,JDIM,WUCOR)
      DO 50 JJ=1,NMT
        J = POINT(JJ)
        PMT(JJ) = PBAR(J)
        WMT(JJ) = WCOR(J)
   50 CONTINUE
      JCK = 0
      CALL MT1D(NMT,PMT,WMT,CH,ZMT,XMT,JDIM,JCK,
     1         XX,MIN,PSIGN,WSIGN,ZSIGN)
      LUB = (ZMT + PWITHW0 + DH*LAMBDA)/ISCALE
      DO 210 JJ=1,NMT
        J = POINT(JJ)
        XLAGR(J) = XMT(JJ)
  210 CONTINUE
C DEFINE THE FEASIBLE PART OF THE LAGRANGIAN SOLUTION
  500 SUMU = 0
      SUMP = 0
      SUMW = 0
      DO 520 J=1,NCOR
        IF ( XLAGR(J) .EQ. 0 ) GO TO 510
        IF ( SUMU + UCOR(J) .GT. DH ) GO TO 510
        SUMU = SUMU + UCOR(J)
        SUMP = SUMP + PCOR(J)
        SUMW = SUMW + WCOR(J)
        XX(J) = 1
        GO TO 520
  510   XX(J) = 0
  520 CONTINUE
      IF ( FLGLOC .EQ. 0 ) GO TO 700
C EXECUTE GREEDY, LOCAL AND LOCALPAIR ON THE FEASIBLE PART OF THE
C LAGRANGIAN SOLUTION AND TAKE THE BEST SOLUTION
C
C GREEDY
      SUMULOC = SUMU
      SUMWLOC = SUMW
      SUMPLOC = SUMP
      DO 525 J=1,NCOR
        XBEST(J) = XX(J)
        IF ( XX(J) .EQ. 1 ) GO TO 525
        IF ( SUMULOC + UCOR(J) .GT. DH ) GO TO 525
        IF ( SUMWLOC + WCOR(J) .GT. CH ) GO TO 525
        SUMULOC = SUMULOC + UCOR(J)
        SUMPLOC = SUMPLOC + PCOR(J)
        SUMWLOC = SUMWLOC + WCOR(J)
        XBEST(J) = 1
  525 CONTINUE
      ZBEST = SUMPLOC/ISCALE
C LOCAL
      ZLOC = SUMP/ISCALE
      ZFLAG = - 1
      DO 530 J=1,NCOR
        XLOC(J) = XX(J)
  530 CONTINUE
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCAL4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZLOC,XLOC,XLOC,
     1           ZFLAG,XLOC,JDIM,ISCALE)
      ENDIF
      IF ( ZLOC .LE. ZBEST ) GO TO 600
      ZBEST = ZLOC
      DO 540 J=1,NCOR
        XBEST(J) = XLOC(J)
  540 CONTINUE
C LOCALPAIR
  600 ZLOC = SUMP/ISCALE
      ZFLAG = - 1
      DO 630 J=1,NCOR
        XLOC(J) = XX(J)
  630 CONTINUE
      CALL LOCALPAIR4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZLOC,XLOC,XLOC,
     1           ZFLAG,XLOC,JDIM,ISCALE)
      IF ( ZLOC .LE. ZBEST ) GO TO 650
      ZBEST = ZLOC
      DO 640 J=1,NCOR
        XBEST(J) = XLOC(J)
  640 CONTINUE
  650 IF ( ZBEST .LE. ZCOR ) RETURN
      ZCOR = ZBEST
      DO 680 J=1,NCOR
        XCOR(J) = XBEST(J)
  680 CONTINUE
      RETURN
C ONLY GREEDY AND LOCAL (IF IMPROVED)
  700 DO 725 J=1,NCOR
        IF ( XLAGR(J) .EQ. 1 ) GO TO 725
        IF ( SUMU + UCOR(J) .GT. DH ) GO TO 725
        IF ( SUMW + WCOR(J) .GT. CH ) GO TO 725
        SUMU = SUMU + UCOR(J)
        SUMP = SUMP + PCOR(J)
        SUMW = SUMW + WCOR(J)
        XX(J) = 1
  725 CONTINUE
      IF (SUMP/ISCALE .LE. ZCOR ) RETURN
      ZCOR = SUMP/ISCALE
      DO 730 J=1,NCOR
        XCOR(J) = XX(J)
  730 CONTINUE
      ZFLAG = -1
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCAL4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,XCOR,XCOR,
     1           ZFLAG,XCOR,JDIM,ISCALE)
      ENDIF
      RETURN
      END
      SUBROUTINE KPUB12(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,XCOR,ISCALE,
     1                    JDIM,LUB,LAMBDA,XLAGR,FLGLOC,FLAGLOC)
C COMPUTE THE LAGRANGIAN UPPER BOUND FOR THE TWO-DIMENSIONAL KP
C BY EXACTLY SOLVING THE 0-1 SINGLE KP FOR MULTIPLIER LAMBDA
C
C RETURN WITHOUT COMPLETING THE EXECUTION IF EITHER
C    A FEASIBLE SOLUTION IS FOUND OF VALUE GREATER THAN ZCOR, OR
C    THE INITIAL UPPER BOUND IS NO GREATER THAN ZCOR
C
C INPUT:
C   CURRENT PROBLEM: NCOR, PCOR/ISCALE, WCOR, UCOR
C                    CH, DH WITH BEST INCUMBENT SOLUTION VALUE ZCOR;
C                    THE TOTAL WEIGHT WCOR IS .GT. CH,
C                    NCOR IS AT LEAST 3,
C   LAMBDA = GIVEN MULTIPLIER
C   FLGLOC = 1 IF LOCAL AND LOCALPAIR MUST BE EXECUTED ON THE FEASIBLE
C            PART OF THE LAGRANGIAN SOLUTION
C
C OUTPUT:
C   LUB = LAGRANGIAN UPPER BOUND FOR THE EXACT SOLUTION
C   XLAGR  = SOLUTION VECTOR PRODUCING LUB
C   ZCOR = BEST SOLUTION VALUE FOUND (IF > ZCOR(INPUT)) FOR THE CURRENT PROBLEM
C   XCOR = SOLUTION VECTOR PRODUCING ZCOR
C
      IMPLICIT NONE
      INTEGER JDIM, NCOR, J, LUB, JJ, ISCALE, LAMBDA
      INTEGER PCOR(JDIM), WCOR(JDIM), UCOR(JDIM), XLAGR(JDIM)
      INTEGER XCOR(JDIM)
      DOUBLE PRECISION RAT(10002)
      INTEGER POINT(10002), ZCOR, CH, DH, PBAR(10002)
      INTEGER NMT, PMT(10002), WMT(10002), SUMW, SUMP, SUMU, ZMT
      INTEGER XMT(10002), XX(10002), MIN(10002), PSIGN(10002),
     1        WSIGN(10002), ZSIGN(10002), JCK
      REAL    WUCOR(10002)
      INTEGER PWITHW0
      INTEGER ZFLAG
      INTEGER FLGLOC, ZBEST, XBEST(10002), ZLOC, XLOC(1002)
      INTEGER SUMULOC, SUMWLOC, SUMPLOC
      INTEGER FLAGLOC
      INTEGER ADDZCOR
      DO 3 J=1,NCOR
        XLAGR(J) = 0
    3 CONTINUE
      PWITHW0 = 0
      NMT = 0
      SUMW = 0
      SUMP = 0
      SUMU = 0
      DO 10 J=1,NCOR
        PBAR(J) = PCOR(J) - LAMBDA*UCOR(J)
        IF ( PBAR(J) .LE. 0 ) GO TO 10
        IF ( WCOR(J) .GT. CH ) GO TO 10
        IF ( UCOR(J) .GT. DH ) GO TO 10
        IF ( WCOR(J) .GT. 0 ) GO TO 5
        PWITHW0 = PWITHW0 + PBAR(J)
        XLAGR(J) = 1
        GO TO 10
    5   NMT = NMT + 1
        POINT(NMT) = J
        RAT(J) = DBLE(PBAR(J))/DBLE(WCOR(J))
        SUMW = SUMW + WCOR(J)
        SUMP = SUMP + PBAR(J)
        SUMU = SUMU + UCOR(J)
        IF ( UCOR(J) .GT. 0 ) GO TO 7
        WUCOR(J) = CH
        GO TO 10
    7   WUCOR(J) = FLOAT(WCOR(J))/UCOR(J)
   10 CONTINUE
      IF ( SUMW .GT. CH .AND. NMT .GT. 2 ) GO TO 200
C SPECIAL CASES
      IF ( SUMW .GT. CH ) GO TO 100
C ALL ITEMS FIT
      LUB = (PWITHW0 + SUMP + DH*LAMBDA)/ISCALE
      DO 70 J=1,NMT
        XLAGR(POINT(J)) = 1
   70 CONTINUE
      GO TO 500
C NMT = 2
  100 IF ( PBAR(POINT(1)) .LT. PBAR(POINT(2)) ) GO TO 120
      LUB = (PWITHW0 + PBAR(POINT(1)) + DH*LAMBDA)/ISCALE
      XLAGR(POINT(1)) = 1
      GO TO 500
  120 LUB = (PWITHW0 + PBAR(POINT(2)) + DH*LAMBDA)/ISCALE
      XLAGR(POINT(2)) = 1
      GO TO 500
C EXACTLY SOLVE THE LAGRANGIAN PROBLEM
  200 CALL SORTRDRD(NMT,RAT,POINT,JDIM,WUCOR)
      DO 50 JJ=1,NMT
        J = POINT(JJ)
        PMT(JJ) = PBAR(J)
        WMT(JJ) = WCOR(J)
   50 CONTINUE
      JCK = 0
      ADDZCOR = PWITHW0 + DH*LAMBDA
      CALL MT1D2(NMT,PMT,WMT,CH,ZMT,XMT,ZCOR,ADDZCOR,ISCALE,JDIM,JCK,
     1         XX,MIN,PSIGN,WSIGN,ZSIGN)
      LUB = (ZMT + ADDZCOR)/ISCALE
      IF ( ZMT .EQ. ZCOR*ISCALE - ADDZCOR ) RETURN
      DO 210 JJ=1,NMT
        J = POINT(JJ)
        XLAGR(J) = XMT(JJ)
  210 CONTINUE
C DEFINE THE FEASIBLE PART OF THE LAGRANGIAN SOLUTION
  500 SUMU = 0
      SUMP = 0
      SUMW = 0
      DO 520 J=1,NCOR
        IF ( XLAGR(J) .EQ. 0 ) GO TO 510
        IF ( SUMU + UCOR(J) .GT. DH ) GO TO 510
        SUMU = SUMU + UCOR(J)
        SUMP = SUMP + PCOR(J)
        SUMW = SUMW + WCOR(J)
        XX(J) = 1
        GO TO 520
  510   XX(J) = 0
  520 CONTINUE
      IF ( FLGLOC .EQ. 0 ) GO TO 700
C EXECUTE GREEDY, LOCAL AND LOCALPAIR ON THE FEASIBLE PART OF THE
C LAGRANGIAN SOLUTION AND TAKE THE BEST SOLUTION
C
C GREEDY
      SUMULOC = SUMU
      SUMWLOC = SUMW
      SUMPLOC = SUMP
      DO 525 J=1,NCOR
        XBEST(J) = XX(J)
        IF ( XX(J) .EQ. 1 ) GO TO 525
        IF ( SUMULOC + UCOR(J) .GT. DH ) GO TO 525
        IF ( SUMWLOC + WCOR(J) .GT. CH ) GO TO 525
        SUMULOC = SUMULOC + UCOR(J)
        SUMPLOC = SUMPLOC + PCOR(J)
        SUMWLOC = SUMWLOC + WCOR(J)
        XBEST(J) = 1
  525 CONTINUE
      ZBEST = SUMPLOC/ISCALE
C LOCAL
      ZLOC = SUMP/ISCALE
      ZFLAG = - 1
      DO 530 J=1,NCOR
        XLOC(J) = XX(J)
  530 CONTINUE
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCAL4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZLOC,XLOC,XLOC,
     1           ZFLAG,XLOC,JDIM,ISCALE)
      ENDIF
      IF ( ZLOC .LE. ZBEST ) GO TO 600
      ZBEST = ZLOC
      DO 540 J=1,NCOR
        XBEST(J) = XLOC(J)
  540 CONTINUE
C LOCALPAIR
  600 ZLOC = SUMP/ISCALE
      ZFLAG = - 1
      DO 630 J=1,NCOR
        XLOC(J) = XX(J)
  630 CONTINUE
      CALL LOCALPAIR4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZLOC,XLOC,XLOC,
     1           ZFLAG,XLOC,JDIM,ISCALE)
      IF ( ZLOC .LE. ZBEST ) GO TO 650
      ZBEST = ZLOC
      DO 640 J=1,NCOR
        XBEST(J) = XLOC(J)
  640 CONTINUE
  650 IF ( ZBEST .LE. ZCOR ) RETURN
      ZCOR = ZBEST
      DO 680 J=1,NCOR
        XCOR(J) = XBEST(J)
  680 CONTINUE
      RETURN
C ONLY GREEDY AND LOCAL (IF IMPROVED)
  700 DO 725 J=1,NCOR
        IF ( XLAGR(J) .EQ. 1 ) GO TO 725
        IF ( SUMU + UCOR(J) .GT. DH ) GO TO 725
        IF ( SUMW + WCOR(J) .GT. CH ) GO TO 725
        SUMU = SUMU + UCOR(J)
        SUMP = SUMP + PCOR(J)
        SUMW = SUMW + WCOR(J)
        XX(J) = 1
  725 CONTINUE
      IF (SUMP/ISCALE .LE. ZCOR ) RETURN
      ZCOR = SUMP/ISCALE
      DO 730 J=1,NCOR
        XCOR(J) = XX(J)
  730 CONTINUE
      ZFLAG = -1
      IF ( FLAGLOC .EQ. 1 ) THEN
        CALL LOCAL4(NCOR,PCOR,WCOR,UCOR,CH,DH,ZCOR,XCOR,XCOR,
     1           ZFLAG,XCOR,JDIM,ISCALE)
      ENDIF
      RETURN
      END
      SUBROUTINE MT1D(N,P,W,C,Z,X,JDIM,JCK,XX,MIN,PSIGN,WSIGN,ZSIGN)
C WITH DOUBLE PRECISION IN PRODUCTS INVOLVING PROFITS
C
C THIS SUBROUTINE SOLVES THE 0-1 SINGLE KNAPSACK PROBLEM
C
C MAXIMIZE  Z = P(1)*X(1) + ... + P(N)*X(N)
C
C SUBJECT TO:   W(1)*X(1) + ... + W(N)*X(N) .LE. C ,
C               X(J) = 0 OR 1  FOR J=1,...,N.
C
C THE PROGRAM IS INCLUDED IN THE VOLUME
C   S. MARTELLO, P. TOTH, "KNAPSACK PROBLEMS: ALGORITHMS
C   AND COMPUTER IMPLEMENTATIONS", JOHN WILEY, 1990
C AND IMPLEMENTS THE BRANCH-AND-BOUND ALGORITHM DESCRIBED IN
C SECTION  2.5.2 .
C THE PROGRAM DERIVES FROM AN EARLIER CODE PRESENTED IN
C  S. MARTELLO, P. TOTH, "ALGORITHM FOR THE SOLUTION OF THE 0-1 SINGLE
C  KNAPSACK PROBLEM", COMPUTING, 1978.
C
C THE INPUT PROBLEM MUST SATISFY THE CONDITIONS
C
C   1) 2 .LE. N .LE. JDIM - 1 ;
C   2) P(J), W(J), C  POSITIVE INTEGERS;
C   3) MAX (W(J)) .LE. C ;
C   4) W(1) + ... + W(N) .GT. C ;
C   5) P(J)/W(J) .GE. P(J+1)/W(J+1) FOR J=1,...,N-1.
C
C MT1 CALLS  1  PROCEDURE: CHMT1.
C
C THE PROGRAM IS COMPLETELY SELF-CONTAINED AND COMMUNICATION TO IT IS
C ACHIEVED SOLELY THROUGH THE PARAMETER LIST OF MT1.
C NO MACHINE-DEPENDENT CONSTANT IS USED.
C THE PROGRAM IS WRITTEN IN 1967 AMERICAN NATIONAL STANDARD FORTRAN
C AND IS ACCEPTED BY THE PFORT VERIFIER (PFORT IS THE PORTABLE
C SUBSET OF ANSI DEFINED BY THE ASSOCIATION FOR COMPUTING MACHINERY).
C THE PROGRAM HAS BEEN TESTED ON A DIGITAL VAX 11/780 AND AN H.P.
C 9000/840.
C
C MT1 NEEDS  8  ARRAYS ( P ,  W ,  X ,  XX ,  MIN ,  PSIGN ,  WSIGN
C                        AND  ZSIGN ) OF LENGTH AT LEAST  N + 1 .
C
C MEANING OF THE INPUT PARAMETERS:
C N    = NUMBER OF ITEMS;
C P(J) = PROFIT OF ITEM  J  (J=1,...,N);
C W(J) = WEIGHT OF ITEM  J  (J=1,...,N);
C C    = CAPACITY OF THE KNAPSACK;
C JDIM = DIMENSION OF THE 8 ARRAYS;
C JCK  = 1 IF CHECK ON THE INPUT DATA IS DESIRED,
C      = 0 OTHERWISE.
C
C MEANING OF THE OUTPUT PARAMETERS:
C Z    = VALUE OF THE OPTIMAL SOLUTION IF  Z .GT. 0 ,
C      = ERROR IN THE INPUT DATA (WHEN JCK=1) IF Z .LT. 0 : CONDI-
C        TION  - Z  IS VIOLATED;
C X(J) = 1 IF ITEM  J  IS IN THE OPTIMAL SOLUTION,
C      = 0 OTHERWISE.
C
C ARRAYS XX, MIN, PSIGN, WSIGN AND ZSIGN ARE DUMMY.
C
C ALL THE PARAMETERS ARE INTEGER. ON RETURN OF MT1 ALL THE INPUT
C PARAMETERS ARE UNCHANGED.
C
      INTEGER P(JDIM),W(JDIM),X(JDIM),C,Z
      INTEGER XX(JDIM),MIN(JDIM),PSIGN(JDIM),WSIGN(JDIM),ZSIGN(JDIM)
      INTEGER CH,CHS,DIFF,PROFIT,R,T
      Z = 0
      IF ( JCK .EQ. 1 ) CALL CHMT1(N,P,W,C,Z,JDIM)
      IF ( Z .LT. 0 ) RETURN
C INITIALIZE.
      CH = C
      IP = 0
      CHS = CH
      DO 10 LL=1,N
        IF ( W(LL) .GT. CHS ) GO TO 20
        IP = IP + P(LL)
        CHS = CHS - W(LL)
   10 CONTINUE
   20 LL = LL - 1
      IF ( CHS .EQ. 0 ) GO TO 50
      P(N+1) = 0
      W(N+1) = CH + 1
      LIM = IP + DBLE(CHS)*P(LL+2)/W(LL+2)
      A = W(LL+1) - CHS
      B = IP + P(LL+1)
      LIM1 = B - DBLE(A)*FLOAT(P(LL))/FLOAT(W(LL))
      IF ( LIM1 .GT. LIM ) LIM = LIM1
      MINK = CH + 1
      MIN(N) = MINK
      DO 30 J=2,N
        KK = N + 2 - J
        IF ( W(KK) .LT. MINK ) MINK = W(KK)
        MIN(KK-1) = MINK
   30 CONTINUE
      DO 40 J=1,N
        XX(J) = 0
   40 CONTINUE
      Z = 0
      PROFIT = 0
      LOLD = N
      II = 1
      GO TO 170
   50 Z = IP
      DO 60 J=1,LL
        X(J) = 1
   60 CONTINUE
      NN = LL + 1
      DO 70 J=NN,N
        X(J) = 0
   70 CONTINUE
      RETURN
C TRY TO INSERT THE II-TH ITEM INTO THE CURRENT SOLUTION.
   80 IF ( W(II) .LE. CH ) GO TO 90
      II1 = II + 1
      IF ( Z .GE. DBLE(CH)*P(II1)/W(II1) + PROFIT ) GO TO 280
      II = II1
      GO TO 80
C BUILD A NEW CURRENT SOLUTION.
   90 IP = PSIGN(II)
      CHS = CH - WSIGN(II)
      IN = ZSIGN(II)
      DO 100 LL=IN,N
        IF ( W(LL) .GT. CHS ) GO TO 160
        IP = IP + P(LL)
        CHS = CHS - W(LL)
  100 CONTINUE
      LL = N
  110 IF ( Z .GE. IP + PROFIT ) GO TO 280
      Z = IP + PROFIT
      NN = II - 1
      DO 120 J=1,NN
        X(J) = XX(J)
  120 CONTINUE
      DO 130 J=II,LL
        X(J) = 1
  130 CONTINUE
      IF ( LL .EQ. N ) GO TO 150
      NN = LL + 1
      DO 140 J=NN,N
        X(J) = 0
  140 CONTINUE
  150 IF ( Z .NE. LIM ) GO TO 280
      RETURN
  160 IU = DBLE(CHS)*P(LL)/W(LL)
      LL = LL - 1
      IF ( IU .EQ. 0 ) GO TO 110
      IF ( Z .GE. PROFIT + IP + IU ) GO TO 280
C SAVE THE CURRENT SOLUTION.
  170 WSIGN(II) = CH - CHS
      PSIGN(II) = IP
      ZSIGN(II) = LL + 1
      XX(II) = 1
      NN = LL - 1
      IF ( NN .LT. II) GO TO 190
      DO 180 J=II,NN
        WSIGN(J+1) = WSIGN(J) - W(J)
        PSIGN(J+1) = PSIGN(J) - P(J)
        ZSIGN(J+1) = LL + 1
        XX(J+1) = 1
  180 CONTINUE
  190 J1 = LL + 1
      DO 200 J=J1,LOLD
        WSIGN(J) = 0
        PSIGN(J) = 0
        ZSIGN(J) = J
  200 CONTINUE
      LOLD = LL
      CH = CHS
      PROFIT = PROFIT + IP
      IF ( LL - (N - 2) ) 240, 220, 210
  210 II = N
      GO TO 250
  220 IF ( CH .LT. W(N) ) GO TO 230
      CH = CH - W(N)
      PROFIT = PROFIT + P(N)
      XX(N) = 1
  230 II = N - 1
      GO TO 250
  240 II = LL + 2
      IF ( CH .GE. MIN(II-1) ) GO TO 80
C SAVE THE CURRENT OPTIMAL SOLUTION.
  250 IF ( Z .GE. PROFIT ) GO TO 270
      Z = PROFIT
      DO 260 J=1,N
        X(J) = XX(J)
  260 CONTINUE
      IF ( Z .EQ. LIM ) RETURN
  270 IF ( XX(N) .EQ. 0 ) GO TO 280
      XX(N) = 0
      CH = CH + W(N)
      PROFIT = PROFIT - P(N)
C BACKTRACK.
  280 NN = II - 1
      IF ( NN .EQ. 0 ) RETURN
      DO 290 J=1,NN
        KK = II - J
        IF ( XX(KK) .EQ. 1 ) GO TO 300
  290 CONTINUE
      RETURN
  300 R = CH
      CH = CH + W(KK)
      PROFIT = PROFIT - P(KK)
      XX(KK) = 0
      IF ( R .LT. MIN(KK) ) GO TO 310
      II = KK + 1
      GO TO 80
  310 NN = KK + 1
      II = KK
C TRY TO SUBSTITUTE THE NN-TH ITEM FOR THE KK-TH.
  320 IF ( Z .GE. PROFIT + DBLE(CH)*P(NN)/W(NN) ) GO TO 280
      DIFF = W(NN) - W(KK)
      IF ( DIFF ) 370, 330, 340
  330 NN = NN + 1
      GO TO 320
  340 IF ( DIFF .GT. R ) GO TO 330
      IF ( Z .GE. PROFIT + P(NN) ) GO TO 330
      Z = PROFIT + P(NN)
      DO 350 J=1,KK
        X(J) = XX(J)
  350 CONTINUE
      JJ = KK + 1
      DO 360 J=JJ,N
        X(J) = 0
  360 CONTINUE
      X(NN) = 1
      IF ( Z .EQ. LIM ) RETURN
      R = R - DIFF
      KK = NN
      NN = NN + 1
      GO TO 320
  370 T = R - DIFF
      IF ( T .LT. MIN(NN) ) GO TO 330
      IF ( Z .GE. PROFIT + P(NN) + DBLE(T)*P(NN+1)/W(NN+1)) GO TO 280
      CH = CH - W(NN)
      PROFIT = PROFIT + P(NN)
      XX(NN) = 1
      II = NN + 1
      WSIGN(NN) = W(NN)
      PSIGN(NN) = P(NN)
      ZSIGN(NN) = II
      N1 = NN + 1
      DO 380 J=N1,LOLD
        WSIGN(J) = 0
        PSIGN(J) = 0
        ZSIGN(J) = J
  380 CONTINUE
      LOLD = NN
      GO TO 80
      END
      SUBROUTINE MT1D2(N,P,W,C,Z,X,ZCOR,ADDZCOR,ISCALE,JDIM,JCK,
     1                 XX,MIN,PSIGN,WSIGN,ZSIGN)
C WITH DOUBLE PRECISION IN PRODUCTS INVOLVING PROFITS
C RETURN WITHOUT COMPLETING THE EXECUTION IF EITHER
C    A FEASIBLE SOLUTION IS FOUND OF TRANSFORMED VALUE GREATER THAN ZCOR,
C OR
C    THE TRANSFORMED INITIAL UPPER BOUND IS NO GREATER THAN ZCOR
C
C
C THIS SUBROUTINE SOLVES THE 0-1 SINGLE KNAPSACK PROBLEM
C
C MAXIMIZE  Z = P(1)*X(1) + ... + P(N)*X(N)
C
C SUBJECT TO:   W(1)*X(1) + ... + W(N)*X(N) .LE. C ,
C               X(J) = 0 OR 1  FOR J=1,...,N.
C
C THE PROGRAM IS INCLUDED IN THE VOLUME
C   S. MARTELLO, P. TOTH, "KNAPSACK PROBLEMS: ALGORITHMS
C   AND COMPUTER IMPLEMENTATIONS", JOHN WILEY, 1990
C AND IMPLEMENTS THE BRANCH-AND-BOUND ALGORITHM DESCRIBED IN
C SECTION  2.5.2 .
C THE PROGRAM DERIVES FROM AN EARLIER CODE PRESENTED IN
C  S. MARTELLO, P. TOTH, "ALGORITHM FOR THE SOLUTION OF THE 0-1 SINGLE
C  KNAPSACK PROBLEM", COMPUTING, 1978.
C
C THE INPUT PROBLEM MUST SATISFY THE CONDITIONS
C
C   1) 2 .LE. N .LE. JDIM - 1 ;
C   2) P(J), W(J), C  POSITIVE INTEGERS;
C   3) MAX (W(J)) .LE. C ;
C   4) W(1) + ... + W(N) .GT. C ;
C   5) P(J)/W(J) .GE. P(J+1)/W(J+1) FOR J=1,...,N-1.
C
C MT1 CALLS  1  PROCEDURE: CHMT1.
C
C THE PROGRAM IS COMPLETELY SELF-CONTAINED AND COMMUNICATION TO IT IS
C ACHIEVED SOLELY THROUGH THE PARAMETER LIST OF MT1.
C NO MACHINE-DEPENDENT CONSTANT IS USED.
C THE PROGRAM IS WRITTEN IN 1967 AMERICAN NATIONAL STANDARD FORTRAN
C AND IS ACCEPTED BY THE PFORT VERIFIER (PFORT IS THE PORTABLE
C SUBSET OF ANSI DEFINED BY THE ASSOCIATION FOR COMPUTING MACHINERY).
C THE PROGRAM HAS BEEN TESTED ON A DIGITAL VAX 11/780 AND AN H.P.
C 9000/840.
C
C MT1 NEEDS  8  ARRAYS ( P ,  W ,  X ,  XX ,  MIN ,  PSIGN ,  WSIGN
C                        AND  ZSIGN ) OF LENGTH AT LEAST  N + 1 .
C
C MEANING OF THE INPUT PARAMETERS:
C N    = NUMBER OF ITEMS;
C P(J) = PROFIT OF ITEM  J  (J=1,...,N);
C W(J) = WEIGHT OF ITEM  J  (J=1,...,N);
C C    = CAPACITY OF THE KNAPSACK;
C JDIM = DIMENSION OF THE 8 ARRAYS;
C JCK  = 1 IF CHECK ON THE INPUT DATA IS DESIRED,
C      = 0 OTHERWISE.
C
C MEANING OF THE OUTPUT PARAMETERS:
C Z    = VALUE OF THE OPTIMAL SOLUTION IF  Z .GT. 0 ,
C      = ERROR IN THE INPUT DATA (WHEN JCK=1) IF Z .LT. 0 : CONDI-
C        TION  - Z  IS VIOLATED;
C X(J) = 1 IF ITEM  J  IS IN THE OPTIMAL SOLUTION,
C      = 0 OTHERWISE.
C
C ARRAYS XX, MIN, PSIGN, WSIGN AND ZSIGN ARE DUMMY.
C
C ALL THE PARAMETERS ARE INTEGER. ON RETURN OF MT1 ALL THE INPUT
C PARAMETERS ARE UNCHANGED.
C
      INTEGER P(JDIM),W(JDIM),X(JDIM),C,Z
      INTEGER XX(JDIM),MIN(JDIM),PSIGN(JDIM),WSIGN(JDIM),ZSIGN(JDIM)
      INTEGER CH,CHS,DIFF,PROFIT,R,T
      INTEGER ZCOR,ADDZCOR,ISCALE
      Z = ZCOR*ISCALE - ADDZCOR
      IF ( JCK .EQ. 1 ) CALL CHMT1(N,P,W,C,Z,JDIM)
      IF ( Z .LT. 0 ) RETURN
C INITIALIZE.
      CH = C
      IP = 0
      CHS = CH
      DO 10 LL=1,N
        IF ( W(LL) .GT. CHS ) GO TO 20
        IP = IP + P(LL)
        CHS = CHS - W(LL)
   10 CONTINUE
   20 LL = LL - 1
      IF ( CHS .EQ. 0 ) GO TO 50
      P(N+1) = 0
      W(N+1) = CH + 1
      LIM = IP + DBLE(CHS)*P(LL+2)/W(LL+2)
      A = W(LL+1) - CHS
      B = IP + P(LL+1)
      LIM1 = B - DBLE(A)*FLOAT(P(LL))/FLOAT(W(LL))
      IF ( LIM1 .GT. LIM ) LIM = LIM1
      IF ( (LIM + ADDZCOR)/ISCALE .LE. ZCOR ) RETURN
      MINK = CH + 1
      MIN(N) = MINK
      DO 30 J=2,N
        KK = N + 2 - J
        IF ( W(KK) .LT. MINK ) MINK = W(KK)
        MIN(KK-1) = MINK
   30 CONTINUE
      DO 40 J=1,N
        XX(J) = 0
   40 CONTINUE
      PROFIT = 0
      LOLD = N
      II = 1
      GO TO 170
   50 CONTINUE
C   50 IF ( (IP + ADDZCOR)/ISCALE .LE. ZCOR ) RETURN
      Z = IP
      DO 60 J=1,LL
        X(J) = 1
   60 CONTINUE
      NN = LL + 1
      DO 70 J=NN,N
        X(J) = 0
   70 CONTINUE
      RETURN
C TRY TO INSERT THE II-TH ITEM INTO THE CURRENT SOLUTION.
   80 IF ( W(II) .LE. CH ) GO TO 90
      II1 = II + 1
      IF ( Z .GE. DBLE(CH)*P(II1)/W(II1) + PROFIT ) GO TO 280
      II = II1
      GO TO 80
C BUILD A NEW CURRENT SOLUTION.
   90 IP = PSIGN(II)
      CHS = CH - WSIGN(II)
      IN = ZSIGN(II)
      DO 100 LL=IN,N
        IF ( W(LL) .GT. CHS ) GO TO 160
        IP = IP + P(LL)
        CHS = CHS - W(LL)
  100 CONTINUE
      LL = N
  110 IF ( Z .GE. IP + PROFIT ) GO TO 280
      Z = IP + PROFIT
      NN = II - 1
      DO 120 J=1,NN
        X(J) = XX(J)
  120 CONTINUE
      DO 130 J=II,LL
        X(J) = 1
  130 CONTINUE
      IF ( LL .EQ. N ) GO TO 150
      NN = LL + 1
      DO 140 J=NN,N
        X(J) = 0
  140 CONTINUE
  150 IF ( (Z + ADDZCOR)/ISCALE .LE. ZCOR ) GO TO 280
      RETURN
  160 IU = DBLE(CHS)*P(LL)/W(LL)
      LL = LL - 1
      IF ( IU .EQ. 0 ) GO TO 110
      IF ( Z .GE. PROFIT + IP + IU ) GO TO 280
C SAVE THE CURRENT SOLUTION.
  170 WSIGN(II) = CH - CHS
      PSIGN(II) = IP
      ZSIGN(II) = LL + 1
      XX(II) = 1
      NN = LL - 1
      IF ( NN .LT. II) GO TO 190
      DO 180 J=II,NN
        WSIGN(J+1) = WSIGN(J) - W(J)
        PSIGN(J+1) = PSIGN(J) - P(J)
        ZSIGN(J+1) = LL + 1
        XX(J+1) = 1
  180 CONTINUE
  190 J1 = LL + 1
      DO 200 J=J1,LOLD
        WSIGN(J) = 0
        PSIGN(J) = 0
        ZSIGN(J) = J
  200 CONTINUE
      LOLD = LL
      CH = CHS
      PROFIT = PROFIT + IP
      IF ( LL - (N - 2) ) 240, 220, 210
  210 II = N
      GO TO 250
  220 IF ( CH .LT. W(N) ) GO TO 230
      CH = CH - W(N)
      PROFIT = PROFIT + P(N)
      XX(N) = 1
  230 II = N - 1
      GO TO 250
  240 II = LL + 2
      IF ( CH .GE. MIN(II-1) ) GO TO 80
C SAVE THE CURRENT OPTIMAL SOLUTION.
  250 IF ( Z .GE. PROFIT ) GO TO 270
      Z = PROFIT
      DO 260 J=1,N
        X(J) = XX(J)
  260 CONTINUE
      IF ( (Z + ADDZCOR)/ISCALE .GT. ZCOR ) RETURN
  270 IF ( XX(N) .EQ. 0 ) GO TO 280
      XX(N) = 0
      CH = CH + W(N)
      PROFIT = PROFIT - P(N)
C BACKTRACK.
  280 NN = II - 1
      IF ( NN .EQ. 0 ) RETURN
      DO 290 J=1,NN
        KK = II - J
        IF ( XX(KK) .EQ. 1 ) GO TO 300
  290 CONTINUE
      RETURN
  300 R = CH
      CH = CH + W(KK)
      PROFIT = PROFIT - P(KK)
      XX(KK) = 0
      IF ( R .LT. MIN(KK) ) GO TO 310
      II = KK + 1
      GO TO 80
  310 NN = KK + 1
      II = KK
C TRY TO SUBSTITUTE THE NN-TH ITEM FOR THE KK-TH.
  320 IF ( Z .GE. PROFIT + DBLE(CH)*P(NN)/W(NN) ) GO TO 280
      DIFF = W(NN) - W(KK)
      IF ( DIFF ) 370, 330, 340
  330 NN = NN + 1
      GO TO 320
  340 IF ( DIFF .GT. R ) GO TO 330
      IF ( Z .GE. PROFIT + P(NN) ) GO TO 330
      Z = PROFIT + P(NN)
      DO 350 J=1,KK
        X(J) = XX(J)
  350 CONTINUE
      JJ = KK + 1
      DO 360 J=JJ,N
        X(J) = 0
  360 CONTINUE
      X(NN) = 1
      IF ( (Z + ADDZCOR)/ISCALE .GT. ZCOR ) RETURN
      R = R - DIFF
      KK = NN
      NN = NN + 1
      GO TO 320
  370 T = R - DIFF
      IF ( T .LT. MIN(NN) ) GO TO 330
      IF ( Z .GE. PROFIT + P(NN) + DBLE(T)*P(NN+1)/W(NN+1)) GO TO 280
      CH = CH - W(NN)
      PROFIT = PROFIT + P(NN)
      XX(NN) = 1
      II = NN + 1
      WSIGN(NN) = W(NN)
      PSIGN(NN) = P(NN)
      ZSIGN(NN) = II
      N1 = NN + 1
      DO 380 J=N1,LOLD
        WSIGN(J) = 0
        PSIGN(J) = 0
        ZSIGN(J) = J
  380 CONTINUE
      LOLD = NN
      GO TO 80
      END
      SUBROUTINE CHMT1(N,P,W,C,Z,JDIM)
C
C CHECK THE INPUT DATA.
C
      INTEGER P(JDIM),W(JDIM),C,Z
      IF ( N .GE. 2 .AND. N .LE. JDIM - 1 ) GO TO 10
      Z = - 1
      RETURN
   10 IF ( C .GT. 0 ) GO TO 30
   20 Z = - 2
      RETURN
   30 JSW = 0
      RR = FLOAT(P(1))/FLOAT(W(1))
      DO 50 J=1,N
        R = RR
        IF ( P(J) .LE. 0 ) GO TO 20
        IF ( W(J) .LE. 0 ) GO TO 20
        JSW = JSW + W(J)
        IF ( W(J) .LE. C ) GO TO 40
        Z = - 3
        RETURN
   40   RR = FLOAT(P(J))/FLOAT(W(J))
        IF ( RR .LE. R ) GO TO 50
        Z = - 5
        RETURN
   50 CONTINUE
      IF ( JSW .GT. C ) RETURN
      Z = - 4
      RETURN
      END
      SUBROUTINE SORTRMDD(N,A,V,JDA,W)
C
C SORT ARRAY V BY DECREASING VALUES OF DOUBLE PRECISION ARRAY A,
C BREAKING TIES BY DECREASING VALUES OF INTEGER ARRAY W
C (DERIVED FROM SUBROUTINE SORTZV OF THE C.E.R.N. LIBRARY).
C
C JDA           = LENGTH OF ARRAYS A AND W;
C N             = NUMBER OF ELEMENTS OF A TO BE SORTED;
C V(I) (INPUT)  = POINTER TO THE I-TH ELEMENT TO BE SORTED;
C V(I) (OUTPUT) = POINTER TO THE I-TH ELEMENT OF THE SORTED ARRAY.
C
C ON RETURN, ARRAYS A AND W ARE UNCHANGED.
C
      INTEGER V(N),IU(20),IL(20)
      DOUBLE PRECISION A(JDA),T
      INTEGER W(JDA)
      II = 1
      JJ = N
      IF ( N .LE. 1 ) RETURN
      M = 1
      I = II
      J = JJ
   10 IF ( I .GE. J ) GO TO 130
   20 K = I
      IJ = (J + I)/2
      IV = V(IJ)
      T = A(IV)
      IWOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 40
      IF ( A(KI) .LT. T ) GO TO 30
      IF ( W(KI) .GE. IWOFT ) GO TO 40
   30 V(IJ) = KI
      V(I) = IV
      IV = V(IJ)
      T = A(IV)
      IWOFT = W(IV)
   40 L = J
      KI = V(J)
      IF ( A(KI) .LT. T ) GO TO 80
      IF ( A(KI) .GT. T ) GO TO 50
      IF ( W(KI) .LE. IWOFT ) GO TO 80
   50 V(IJ) = KI
      V(J) = IV
      IV = V(IJ)
      T = A(IV)
      IWOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 80
      IF ( A(KI) .LT. T ) GO TO 60
      IF ( W(KI) .GE. IWOFT ) GO TO 80
   60 V(IJ) = KI
      V(I) = IV
      IV = V(IJ)
      T = A(IV)
      IWOFT = W(IV)
      GO TO 80
   70 V(L) = V(K)
      V(K) = IVT
   80 L = L - 1
      KI = V(L)
      IF ( A(KI) .LT. T ) GO TO 80
      IF ( A(KI) .GT. T ) GO TO 90
      IF ( W(KI) .LT. IWOFT ) GO TO 80
   90 IVT = KI
  100 K = K + 1
      KI = V(K)
      IF ( A(KI) .GT. T ) GO TO 100
      IF ( A(KI) .LT. T ) GO TO 110
      IF ( W(KI) .GT. IWOFT ) GO TO 100
  110 IF ( K .LE. L ) GO TO 70
      IF ( L - I .LE. J - K ) GO TO 120
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 140
  120 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 140
  130 M = M - 1
      IF ( M .EQ. 0 ) RETURN
      I = IL(M)
      J = IU(M)
  140 IF ( J - I .GE. II ) GO TO 20
      IF ( I .EQ. II ) GO TO 10
      I = I - 1
  150 I = I + 1
      IF ( I .EQ. J ) GO TO 130
      IV = V(I+1)
      T = A(IV)
      IWOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 150
      IF ( A(KI) .LT. T ) GO TO 160
      IF ( W(KI) .GE. IWOFT ) GO TO 150
  160 K = I
  170 V(K+1) = V(K)
      K = K - 1
      KI = V(K)
      IF ( T .GT. A(KI) ) GO TO 170
      IF ( T .LT. A(KI) ) GO TO 180
      IF ( IWOFT .GT. W(KI) ) GO TO 170
  180 V(K+1) = IV
      GO TO 150
      END
      SUBROUTINE SORTRDRD(N,A,V,JDA,W)
C
C SORT ARRAY V BY DECREASING VALUES OF DOUBLE PRECISION ARRAY A,
C BREAKING TIES BY DECREASING VALUES OF REAL ARRAY W
C (DERIVED FROM SUBROUTINE SORTZV OF THE C.E.R.N. LIBRARY).
C
C JDA           = LENGTH OF ARRAYS A AND W;
C N             = NUMBER OF ELEMENTS OF A TO BE SORTED;
C V(I) (INPUT)  = POINTER TO THE I-TH ELEMENT TO BE SORTED;
C V(I) (OUTPUT) = POINTER TO THE I-TH ELEMENT OF THE SORTED ARRAY.
C
C ON RETURN, ARRAYS A AND W ARE UNCHANGED.
C
      INTEGER V(N),IU(20),IL(20)
      DOUBLE PRECISION A(JDA),T
      REAL W(JDA)
      II = 1
      JJ = N
      IF ( N .LE. 1 ) RETURN
      M = 1
      I = II
      J = JJ
   10 IF ( I .GE. J ) GO TO 130
   20 K = I
      IJ = (J + I)/2
      IV = V(IJ)
      T = A(IV)
      WOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 40
      IF ( A(KI) .LT. T ) GO TO 30
      IF ( W(KI) .GE. WOFT ) GO TO 40
   30 V(IJ) = KI
      V(I) = IV
      IV = V(IJ)
      T = A(IV)
      WOFT = W(IV)
   40 L = J
      KI = V(J)
      IF ( A(KI) .LT. T ) GO TO 80
      IF ( A(KI) .GT. T ) GO TO 50
      IF ( W(KI) .LE. WOFT ) GO TO 80
   50 V(IJ) = KI
      V(J) = IV
      IV = V(IJ)
      T = A(IV)
      WOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 80
      IF ( A(KI) .LT. T ) GO TO 60
      IF ( W(KI) .GE. WOFT ) GO TO 80
   60 V(IJ) = KI
      V(I) = IV
      IV = V(IJ)
      T = A(IV)
      WOFT = W(IV)
      GO TO 80
   70 V(L) = V(K)
      V(K) = IVT
   80 L = L - 1
      KI = V(L)
      IF ( A(KI) .LT. T ) GO TO 80
      IF ( A(KI) .GT. T ) GO TO 90
      IF ( W(KI) .LT. WOFT ) GO TO 80
   90 IVT = KI
  100 K = K + 1
      KI = V(K)
      IF ( A(KI) .GT. T ) GO TO 100
      IF ( A(KI) .LT. T ) GO TO 110
      IF ( W(KI) .GT. WOFT ) GO TO 100
  110 IF ( K .LE. L ) GO TO 70
      IF ( L - I .LE. J - K ) GO TO 120
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 140
  120 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 140
  130 M = M - 1
      IF ( M .EQ. 0 ) RETURN
      I = IL(M)
      J = IU(M)
  140 IF ( J - I .GE. II ) GO TO 20
      IF ( I .EQ. II ) GO TO 10
      I = I - 1
  150 I = I + 1
      IF ( I .EQ. J ) GO TO 130
      IV = V(I+1)
      T = A(IV)
      WOFT = W(IV)
      KI = V(I)
      IF ( A(KI) .GT. T ) GO TO 150
      IF ( A(KI) .LT. T ) GO TO 160
      IF ( W(KI) .GE. WOFT ) GO TO 150
  160 K = I
  170 V(K+1) = V(K)
      K = K - 1
      KI = V(K)
      IF ( T .GT. A(KI) ) GO TO 170
      IF ( T .LT. A(KI) ) GO TO 180
      IF ( WOFT .GT. W(KI) ) GO TO 170
  180 V(K+1) = IV
      GO TO 150
      END
      SUBROUTINE SHUTTLERDRD(N,A,V,JDA,W)
C
C SORT ARRAY V BY DECREASING VALUES OF DOUBLE PRECISION ARRAY A,
C BREAKING TIES BY DECREASING VALUES OF REAL ARRAY W
C THROUGH SHUTTLE SORT
C
C JDA           = LENGTH OF ARRAYS A AND W;
C N             = NUMBER OF ELEMENTS OF A TO BE SORTED;
C V(I) (INPUT)  = POINTER TO THE I-TH ELEMENT TO BE SORTED;
C V(I) (OUTPUT) = POINTER TO THE I-TH ELEMENT OF THE SORTED ARRAY.
C
C ON RETURN, ARRAYS A AND W ARE UNCHANGED.
C
      INTEGER V(N)
      DOUBLE PRECISION A(JDA),K,KPREC,LK,LKPREC
      REAL W(JDA)
      IF ( N .EQ. 1 ) RETURN
      JPREC = V(1)
      KPREC = A(JPREC)
      DO 100 JJ=2,N
        J = V(JJ)
        K = A(J)
        IF ( KPREC .GT. K ) GO TO 90
        IF ( KPREC .LT. K ) GO TO 30
        IF ( W(JPREC) .GE. W(J) ) GO TO 90
   30   V(JJ-1) = J
        V(JJ) = JPREC
        LJPREC = J
        LKPREC = K
        DO 70 LJJ=JJ-2,1,-1
          LJ = V(LJJ)
          LK = A(LJ)
          IF ( LK .GT. LKPREC ) GO TO 100
          IF ( LK .LT. LKPREC ) GO TO 50
          IF ( W(LJ) .GE. W(LJPREC) ) GO TO 100
   50     V(LJJ+1) = LJ
          V(LJJ) = LJPREC
   70   CONTINUE
        GO TO 100
   90   JPREC = J
        KPREC = K
  100 CONTINUE
      RETURN
      END